2023.09.12 08:48:49 INFO  Started: Metals version 1.0.1 in folders '/Users/jpmruiz/Documents/jpmruiz-slick-test' for client Visual Studio Code 1.74.3.
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.license.VersionPrinter printVersionOnly
INFO: Flyway Community Edition 9.21.2 by Redgate
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.license.VersionPrinter printVersion
INFO: See release notes here: https://rd.gt/416ObMi
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.license.VersionPrinter printVersion
INFO: 
Sep 12, 2023 8:48:50 AM org.flywaydb.core.FlywayExecutor execute
INFO: Database: jdbc:h2:file:/Users/jpmruiz/Documents/jpmruiz-slick-test/.metals/metals (H2 2.1)
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory allAppliedMigrations
INFO: Schema history table "PUBLIC"."flyway_schema_history" does not exist yet
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.command.DbValidate validate
INFO: Successfully validated 4 migrations (execution time 00:00.035s)
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory create
INFO: Creating Schema History table "PUBLIC"."flyway_schema_history" ...
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.command.DbMigrate migrateGroup
INFO: Current version of schema "PUBLIC": << Empty Schema >>
Sep 12, 2023 8:48:50 AM org.flywaydb.core.internal.command.DbMigrate doMigrateGroup
INFO: Migrating schema "PUBLIC" to version "1 - Create tables"
Sep 12, 2023 8:48:51 AM org.flywaydb.core.internal.command.DbMigrate doMigrateGroup
INFO: Migrating schema "PUBLIC" to version "2 - Server discovery"
Sep 12, 2023 8:48:51 AM org.flywaydb.core.internal.command.DbMigrate doMigrateGroup
INFO: Migrating schema "PUBLIC" to version "3 - Jar symbols"
Sep 12, 2023 8:48:51 AM org.flywaydb.core.internal.command.DbMigrate doMigrateGroup
INFO: Migrating schema "PUBLIC" to version "4 - Fingerprints"
Sep 12, 2023 8:48:51 AM org.flywaydb.core.internal.command.DbMigrate logSummary
INFO: Successfully applied 4 migrations to schema "PUBLIC", now at version v4 (execution time 00:00.072s)
2023.09.12 08:48:51 INFO  time: initialize in 1.37s
2023.09.12 08:48:52 WARN  Build server is not auto-connectable.
2023.09.12 08:48:52 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 08:48:56 INFO  no build target found for /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt. Using presentation compiler with project's scala-library version: 3.3.0
Sep 12, 2023 8:48:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
Sep 12, 2023 8:48:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3
Sep 12, 2023 8:48:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
Sep 12, 2023 8:48:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2023.09.12 08:48:56 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 08:48:59 INFO  time: code lens generation in 6.85s
2023.09.12 08:48:59 INFO  time: code lens generation in 3.36s
2023.09.12 08:48:59 INFO  time: code lens generation in 3.37s
Sep 12, 2023 8:49:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12
Sep 12, 2023 8:49:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19
2023.09.12 08:49:00 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 08:49:03 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 08:49:05 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 09:02:47 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 09:02:47 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 09:02:47 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 09:16:15 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 09:32:02 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 09:32:02 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 09:32:03 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-slick-test/project/plugins.sbt
2023.09.12 15:34:10 INFO  Shutting down server
2023.09.12 15:34:10 INFO  shutting down Metals
2023.09.12 15:34:10 ERROR Unexpected error initializing server: 
org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.09.12 15:34:10 INFO  Exiting server
2023.09.12 15:35:43 INFO  Started: Metals version 1.0.1 in folders '/Users/jpmruiz/Documents/jpmruiz-slick-test' for client Visual Studio Code 1.74.3.
Sep 12, 2023 3:35:43 PM org.flywaydb.core.internal.license.VersionPrinter printVersionOnly
INFO: Flyway Community Edition 9.21.2 by Redgate
Sep 12, 2023 3:35:43 PM org.flywaydb.core.internal.license.VersionPrinter printVersion
INFO: See release notes here: https://rd.gt/416ObMi
Sep 12, 2023 3:35:43 PM org.flywaydb.core.internal.license.VersionPrinter printVersion
INFO: 
Sep 12, 2023 3:35:45 PM org.flywaydb.core.FlywayExecutor execute
INFO: Database: jdbc:h2:file:/Users/jpmruiz/Documents/jpmruiz-slick-test/.metals/metals (H2 2.1)
Sep 12, 2023 3:35:45 PM org.flywaydb.core.internal.command.DbValidate validate
INFO: Successfully validated 4 migrations (execution time 00:00.057s)
Sep 12, 2023 3:35:45 PM org.flywaydb.core.internal.command.DbMigrate migrateGroup
INFO: Current version of schema "PUBLIC": 4
Sep 12, 2023 3:35:45 PM org.flywaydb.core.internal.command.DbMigrate logSummary
INFO: Schema "PUBLIC" is up to date. No migration necessary.
2023.09.12 15:35:45 INFO  time: initialize in 1.95s
2023.09.12 15:35:47 WARN  Build server is not auto-connectable.
2023.09.12 15:35:47 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt
2023.09.12 15:35:56 INFO  no build target found for /Users/jpmruiz/Documents/jpmruiz-slick-test/build.sbt. Using presentation compiler with project's scala-library version: 3.3.0
2023.09.12 15:36:02 INFO  time: code lens generation in 14s
2023.09.12 15:36:31 INFO  Shutting down server
2023.09.12 15:36:31 INFO  shutting down Metals
2023.09.12 15:36:31 ERROR Unexpected error initializing server: 
org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.09.12 15:36:31 INFO  Exiting server
2023.11.01 09:52:40 INFO  Started: Metals version 1.1.0 in folders '/Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend' for client Visual Studio Code 1.74.3.
2023.11.01 09:52:44 ERROR Unexpected error initializing server: 
scala.concurrent.Future$$anon$2: Future.filter predicate is not satisfied

2023.11.01 09:52:52 INFO  no build target found for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2023.11.01 09:54:07 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/build.sbt
2023.11.01 10:51:54 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala
2023.11.01 10:51:59 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala
2023.11.01 10:52:53 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala
Nov 01, 2023 10:53:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 224
2023.11.01 10:54:09 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala
2023.11.01 10:56:41 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 10:56:46 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 10:57:05 WARN  Could not find semantic tokens for: file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 10:57:06 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 10:57:06 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 10:57:19 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 10:57:26 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 10:58:07 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala
2023.11.01 11:00:07 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
Nov 01, 2023 11:03:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 568
2023.11.01 11:08:22 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 11:08:22 WARN  Using indexes to guess the definition of username
2023.11.01 11:10:22 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
Nov 01, 2023 11:10:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 874
2023.11.01 11:11:08 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("error_form" -> "Invalid fo)
                                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:08 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("error_form" -> "Invali)
                                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:08 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("error_form" -> "In)
                                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:08 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_password" -> "Invalid pa)
                                                                                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:09 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("error_fo)
                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:09 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("erro)
                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:09 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: unclosed string literal
                Future(Redirect(routes.RegisterController.get()).flashing("e)
                                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:11 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_password)
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:11 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_passwo)
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:11 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_pass)
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:11 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_pa)
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:12 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_p)
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:17 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("error_p
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:18 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string literal
                    Future(Redirect(routes.RegisterController.get()).flashing("err
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:17 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("err
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:18 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("err
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:19 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("err
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:19 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("err
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:21 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("err
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:23 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:41: error: unclosed string literal
                        Redirect(routes.RegisterController.get()).flashing("success_reg
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 11:11:27 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:14:52 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
Nov 01, 2023 11:17:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1127
2023.11.01 11:17:11 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:18:11 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:18:22 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
Nov 01, 2023 11:18:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1343
2023.11.01 11:19:00 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:20:06 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:20:13 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:20:50 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:21:02 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:21:21 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:21:38 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:21:39 WARN  Using indexes to guess the definition of RegisterController
2023.11.01 11:21:56 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:22:03 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:22:38 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:22:45 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:23:01 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:23:18 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 11:23:53 WARN  Using indexes to guess the definition of isLogon
2023.11.01 11:27:05 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 11:27:12 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/repo/UserRepo.scala
2023.11.01 11:27:21 INFO  running '/opt/local/sdkman/candidates/java/current/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals7329286185823517494/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2023.11.01 11:27:21 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/metals.sbt
2023.11.01 11:27:21 WARN  no build target for: /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/metals.sbt
2023.11.01 11:27:21 INFO  skipping build import with status 'Started'
2023.11.01 11:27:27 INFO  [info] welcome to sbt 1.7.2 (Amazon.com Inc. Java 1.8.0_382)
2023.11.01 11:27:35 INFO  [info] loading settings for project auth-app-backend-build-build-build from metals.sbt ...
2023.11.01 11:27:37 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/project
2023.11.01 11:27:46 INFO  [info] loading settings for project auth-app-backend-build-build from metals.sbt ...
2023.11.01 11:27:46 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project
2023.11.01 11:27:51 INFO  [success] Generated .bloop/auth-app-backend-build-build.json
2023.11.01 11:27:51 INFO  [success] Total time: 6 s, completed 11 1, 23 11:27:52 AM
2023.11.01 11:27:56 INFO  [info] loading settings for project auth-app-backend-build from metals.sbt,plugins.sbt ...
2023.11.01 11:27:56 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project
2023.11.01 11:28:02 INFO  [success] Generated .bloop/auth-app-backend-build.json
2023.11.01 11:28:02 INFO  [success] Total time: 6 s, completed 11 1, 23 11:28:02 AM
2023.11.01 11:28:14 INFO  [info] loading settings for project root from build.sbt ...
2023.11.01 11:28:14 INFO  [info]   __              __
2023.11.01 11:28:14 INFO  [info]   \ \     ____   / /____ _ __  __
2023.11.01 11:28:14 INFO  [info]    \ \   / __ \ / // __ `// / / /
2023.11.01 11:28:14 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2023.11.01 11:28:14 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2023.11.01 11:28:14 INFO  [info]       /_/               /____/
2023.11.01 11:28:14 INFO  [info] 
2023.11.01 11:28:14 INFO  [info] Version 2.8.20 running Java 1.8.0_382
2023.11.01 11:28:14 INFO  [info] 
2023.11.01 11:28:14 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2023.11.01 11:28:14 INFO  [info] https://www.playframework.com/sponsors
2023.11.01 11:28:14 INFO  [info] 
2023.11.01 11:28:21 INFO  [success] Generated .bloop/root.json
2023.11.01 11:28:21 INFO  [success] Generated .bloop/root-test.json
2023.11.01 11:28:21 INFO  [success] Total time: 5 s, completed 11 1, 23 11:28:21 AM
2023.11.01 11:28:22 INFO  time: ran 'sbt bloopInstall' in 1m
2023.11.01 11:28:22 INFO  Attempting to connect to the build server...
2023.11.01 11:28:22 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 11:28:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 11:28:23 INFO  Attempting to connect to the build server...
2023.11.01 11:28:23 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 11:28:23 INFO  Attempting to connect to the build server...
2023.11.01 11:28:23 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 11:28:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 11:28:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 11:28:23 INFO  time: Connected to build server in 1.14s
2023.11.01 11:28:23 INFO  Connected to Build server: Bloop v1.5.11
2023.11.01 11:28:23 INFO  time: Imported build in 0.18s
2023.11.01 11:28:46 INFO  time: indexed workspace in 23s
2023.11.01 11:29:09 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:29:19 INFO  time: compiled root in 9.69s
2023.11.01 11:29:19 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:29:21 INFO  time: compiled root in 0.94s
2023.11.01 11:29:21 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:29:21 INFO  time: compiled root in 0.55s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8s
2023.11.01 11:29:27 INFO  time: code lens generation in 8.02s
2023.11.01 11:30:03 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:30:10 INFO  time: compiled root in 6.82s
Nov 01, 2023 11:30:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2329
2023.11.01 11:30:21 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:30:24 INFO  time: compiled root in 3.09s
2023.11.01 11:30:33 WARN  Using indexes to guess the definition of update
2023.11.01 11:30:34 WARN  Using indexes to guess the definition of update
2023.11.01 11:31:25 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:31:28 INFO  time: compiled root in 2.39s
2023.11.01 11:31:33 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 11:31:36 INFO  time: compiled root in 2.99s
Nov 01, 2023 11:31:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2469
2023.11.01 11:33:28 INFO  compiling root (10 scala sources and 1 java source)
Nov 01, 2023 11:33:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2528
2023.11.01 11:33:49 INFO  time: compiled root in 21s
2023.11.01 11:34:24 INFO  compiling root (1 scala source)
2023.11.01 11:34:28 INFO  time: compiled root in 3.9s
2023.11.01 11:36:22 INFO  compiling root (3 scala sources and 1 java source)
2023.11.01 11:36:33 INFO  Deduplicating compilation of root from bsp client 'Metals 1.1.0' (since 8m 10.173s)
2023.11.01 11:36:33 INFO  compiling root (3 scala sources and 1 java source)
2023.11.01 11:36:33 INFO  time: compiled root in 0.45s
Nov 01, 2023 11:47:21 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2672
Nov 01, 2023 11:47:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2682
Nov 01, 2023 11:47:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2726
2023.11.01 11:47:39 INFO  compiling root (1 scala source)
2023.11.01 11:47:42 INFO  time: compiled root in 3.25s
2023.11.01 11:47:42 INFO  compiling root (2 scala sources)
2023.11.01 11:47:43 INFO  time: compiled root in 1.04s
Nov 01, 2023 11:47:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2803
Nov 01, 2023 11:47:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2804
2023.11.01 11:47:49 WARN  Using indexes to guess the definition of JsPath
2023.11.01 11:48:46 INFO  compiling root (1 scala source)
2023.11.01 11:48:48 INFO  time: compiled root in 1.6s
Nov 01, 2023 11:48:48 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.01 11:49:10 INFO  compiling root (1 scala source)
2023.11.01 11:49:10 INFO  time: compiled root in 0.91s
2023.11.01 11:49:25 INFO  compiling root (1 scala source)
2023.11.01 11:49:25 INFO  time: compiled root in 0.66s
Nov 01, 2023 11:49:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3144
Nov 01, 2023 11:49:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3145
Nov 01, 2023 11:49:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3172
Nov 01, 2023 11:49:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:49:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:49:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:50:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:50:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:50:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:50:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 01, 2023 11:50:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 447
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2023.11.01 11:50:15 INFO  compiling root (1 scala source)
2023.11.01 11:50:17 INFO  time: compiled root in 1.68s
2023.11.01 11:50:17 INFO  compiling root (2 scala sources)
2023.11.01 11:50:17 INFO  time: compiled root in 0.82s
2023.11.01 11:50:45 INFO  compiling root (2 scala sources)
2023.11.01 11:50:49 INFO  time: compiled root in 3.51s
2023.11.01 11:50:49 INFO  compiling root (2 scala sources)
2023.11.01 11:50:49 INFO  time: compiled root in 0.86s
2023.11.01 11:50:52 INFO  compiling root (2 scala sources)
2023.11.01 11:50:57 INFO  time: compiled root in 4.71s
2023.11.01 11:50:57 INFO  compiling root (2 scala sources)
2023.11.01 11:50:58 INFO  time: compiled root in 1s
2023.11.01 11:50:58 INFO  compiling root (2 scala sources)
2023.11.01 11:51:00 INFO  time: compiled root in 2.02s
2023.11.01 11:51:00 INFO  compiling root (2 scala sources)
2023.11.01 11:51:01 INFO  time: compiled root in 1.01s
Nov 01, 2023 11:55:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3410
2023.11.01 11:55:52 INFO  compiling root (2 scala sources)
2023.11.01 11:55:56 INFO  time: compiled root in 3.82s
2023.11.01 11:55:56 INFO  compiling root (2 scala sources)
2023.11.01 11:55:56 INFO  time: compiled root in 0.73s
2023.11.01 11:55:56 INFO  compiling root (2 scala sources)
2023.11.01 11:55:59 INFO  time: compiled root in 1.99s
2023.11.01 11:55:59 INFO  compiling root (2 scala sources)
2023.11.01 11:56:00 INFO  time: compiled root in 1.55s
2023.11.01 11:56:00 INFO  compiling root (2 scala sources)
2023.11.01 11:56:02 INFO  time: compiled root in 2.12s
2023.11.01 11:56:02 INFO  compiling root (2 scala sources)
2023.11.01 11:56:02 INFO  time: compiled root in 0.97s
2023.11.01 11:56:03 INFO  compiling root (2 scala sources)
2023.11.01 11:56:04 INFO  time: compiled root in 1.06s
2023.11.01 11:56:04 INFO  compiling root (2 scala sources)
2023.11.01 11:56:04 INFO  time: compiled root in 0.53s
Nov 01, 2023 11:56:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3493
Exception in thread "pool-7-thread-1" java.lang.Error: java.lang.InterruptedException
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1155)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	... 2 more
2023.11.01 11:56:59 INFO  compiling root (2 scala sources)
2023.11.01 11:57:02 INFO  time: compiled root in 2.53s
2023.11.01 11:57:02 INFO  compiling root (2 scala sources)
2023.11.01 11:57:04 INFO  time: compiled root in 1.88s
2023.11.01 11:57:25 INFO  compiling root (2 scala sources)
2023.11.01 11:57:28 INFO  time: compiled root in 3.37s
2023.11.01 11:57:28 INFO  compiling root (2 scala sources)
2023.11.01 11:57:28 INFO  time: compiled root in 0.84s
2023.11.01 11:57:31 INFO  compiling root (2 scala sources)
2023.11.01 11:57:34 INFO  time: compiled root in 3.15s
2023.11.01 11:57:34 INFO  compiling root (2 scala sources)
2023.11.01 11:57:34 INFO  time: compiled root in 0.66s
2023.11.01 11:57:40 INFO  compiling root (2 scala sources)
2023.11.01 11:57:42 INFO  time: compiled root in 2.44s
2023.11.01 11:57:42 INFO  compiling root (2 scala sources)
2023.11.01 11:57:42 INFO  time: compiled root in 0.6s
Nov 01, 2023 11:58:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3652
2023.11.01 11:58:51 INFO  compiling root (2 scala sources)
2023.11.01 11:58:53 INFO  time: compiled root in 1.92s
2023.11.01 11:58:53 INFO  compiling root (2 scala sources)
2023.11.01 11:58:53 INFO  time: compiled root in 0.64s
2023.11.01 11:58:53 INFO  compiling root (2 scala sources)
2023.11.01 11:58:54 INFO  time: compiled root in 0.4s
Nov 01, 2023 11:58:54 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.01 11:59:05 INFO  compiling root (2 scala sources)
2023.11.01 11:59:09 INFO  time: compiled root in 4.02s
2023.11.01 11:59:09 INFO  compiling root (2 scala sources)
2023.11.01 11:59:10 INFO  time: compiled root in 1.62s
2023.11.01 11:59:45 INFO  compiling root (3 scala sources)
2023.11.01 11:59:45 INFO  time: compiled root in 0.75s
2023.11.01 11:59:51 INFO  compiling root (2 scala sources)
2023.11.01 11:59:54 INFO  time: compiled root in 2.5s
2023.11.01 11:59:54 INFO  compiling root (2 scala sources)
2023.11.01 11:59:54 INFO  time: compiled root in 0.53s
2023.11.01 12:01:00 WARN  Using indexes to guess the definition of User
2023.11.01 12:01:36 INFO  compiling root (2 scala sources)
2023.11.01 12:01:40 INFO  time: compiled root in 3.9sNov 01, 2023 12:01:40 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.

2023.11.01 12:01:40 INFO  compiling root (2 scala sources)
2023.11.01 12:01:42 INFO  time: compiled root in 1.44s
2023.11.01 12:01:42 INFO  compiling root (2 scala sources)
2023.11.01 12:01:43 WARN  failed to generate semanticdb for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/User.scala:
java.lang.IllegalArgumentException: 543 is not a valid offset, allowed [0..434]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$File.offsetToLine(Input.scala:51)
	at scala.meta.inputs.Position$Range.endLine(Position.scala:41)
	at scala.meta.internal.inputs.package$XtensionPositionToRange$.toRange$extension(package.scala:47)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.tryFindSynthetic(TextDocumentOps.scala:580)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:722)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:210)
	at scala.reflect.internal.Trees$ValDef.$anonfun$traverse$3(Trees.scala:441)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$ValDef.traverse(Trees.scala:437)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:783)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:210)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$Template.traverse(Trees.scala:550)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:783)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:210)
	at scala.reflect.internal.Trees$ModuleDef.$anonfun$traverse$2(Trees.scala:403)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.internal.Trees$ModuleDef.traverse(Trees.scala:400)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:783)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:210)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$2(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.atOwner(Trees.scala:2529)
	at scala.reflect.api.Trees$Traverser.$anonfun$traverseStats$1(Trees.scala:2520)
	at scala.reflect.api.Trees$Traverser.traverseStats(Trees.scala:2519)
	at scala.reflect.internal.Trees$PackageDef.traverse(Trees.scala:349)
	at scala.reflect.internal.Trees.itraverse(Trees.scala:1605)
	at scala.reflect.internal.Trees.itraverse$(Trees.scala:1604)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.internal.SymbolTable.itraverse(SymbolTable.scala:28)
	at scala.reflect.api.Trees$Traverser.traverse(Trees.scala:2497)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$3$.traverse(TextDocumentOps.scala:783)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:786)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:54)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.saveSemanticdbForCompilationUnit(SemanticdbPipeline.scala:59)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.apply(SemanticdbPipeline.scala:65)
	at scala.tools.nsc.Global$GlobalPhase.applyPhase(Global.scala:480)
	at scala.tools.nsc.Global$GlobalPhase.run(Global.scala:427)
	at scala.meta.internal.semanticdb.scalac.SemanticdbPipeline$SemanticdbTyperComponent$ComputeSemanticdbPhase.run(SemanticdbPipeline.scala:75)
	at scala.tools.nsc.Global$Run.compileUnitsInternal(Global.scala:1546)
	at scala.tools.nsc.Global$Run.compileUnits(Global.scala:1530)
	at scala.tools.nsc.Global$Run.compileSources(Global.scala:1522)
	at scala.tools.nsc.Global$Run.compileFiles(Global.scala:1635)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:176)
	at scala.tools.xsbt.CachedCompiler0.run(CompilerBridge.scala:139)
	at scala.tools.xsbt.CompilerBridge.run(CompilerBridge.scala:43)
	at sbt.internal.inc.AnalyzingCompiler.compile(AnalyzingCompiler.scala:91)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.compileSources$1(BloopHighLevelCompiler.scala:133)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$7(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$1(BloopHighLevelCompiler.scala:71)
	at bloop.tracing.BraveTracer.traceInternal(BraveTracer.scala:67)
	at bloop.tracing.BraveTracer.trace(BraveTracer.scala:41)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.timed$1(BloopHighLevelCompiler.scala:70)
	at sbt.internal.inc.bloop.internal.BloopHighLevelCompiler.$anonfun$compile$6(BloopHighLevelCompiler.scala:159)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)
	at monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)
	at monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)
	at monix.eval.internal.TaskExecuteOn$AsyncRegister$$anon$1.run(TaskExecuteOn.scala:71)
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)

2023.11.01 12:01:43 INFO  time: compiled root in 1.93s
2023.11.01 12:01:43 INFO  compiling root (2 scala sources)
2023.11.01 12:01:44 INFO  time: compiled root in 0.79s
2023.11.01 12:01:44 INFO  compiling root (2 scala sources)
2023.11.01 12:01:47 INFO  time: compiled root in 1.99s
2023.11.01 12:01:47 INFO  compiling root (2 scala sources)
2023.11.01 12:01:48 INFO  time: compiled root in 1.78s
Nov 01, 2023 12:04:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3980
2023.11.01 12:08:40 INFO  compiling root (2 scala sources)
2023.11.01 12:08:43 INFO  time: compiled root in 3.02s
2023.11.01 12:08:43 INFO  compiling root (2 scala sources)
2023.11.01 12:08:46 INFO  time: compiled root in 2.85s
2023.11.01 13:09:40 WARN  Using indexes to guess the definition of schema
Nov 01, 2023 1:09:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4218
Nov 01, 2023 1:10:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4272
2023.11.01 13:10:09 INFO  compiling root (1 scala source)
2023.11.01 13:10:10 INFO  time: compiled root in 1.25s
2023.11.01 13:10:23 INFO  compiling root (1 scala source)
2023.11.01 13:10:23 INFO  compiling root (1 scala source)
2023.11.01 13:10:24 INFO  time: compiled root in 0.33s
Nov 01, 2023 1:11:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4463
2023.11.01 13:11:22 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('')
       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:24 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('')
       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:24 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('Sch')
           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:24 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('Schema')
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:24 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('Schema cre')
                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:25 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('Schema create')
                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:26 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed character literal
    Ok('Schema created')
                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

Nov 01, 2023 1:11:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4501
2023.11.01 13:11:30 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/HomeController.scala
scala.meta.tokenizers.TokenizeException: <input>:26: error: unclosed string interpolation
    Ok('Schema created")
                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 13:11:35 INFO  compiling root (1 scala source)
2023.11.01 13:11:37 INFO  time: compiled root in 2.11s
2023.11.01 13:13:34 INFO  compiling root (1 scala source)
2023.11.01 13:13:36 INFO  time: compiled root in 1.94s
2023.11.01 14:07:52 INFO  compiling root (1 scala source)
2023.11.01 14:07:56 INFO  time: compiled root in 3.58s
2023.11.01 14:07:59 INFO  compiling root (1 scala source)
2023.11.01 14:08:02 INFO  time: compiled root in 3.09s
Nov 01, 2023 2:08:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4725
2023.11.01 14:08:12 INFO  compiling root (1 scala source)
2023.11.01 14:08:14 INFO  time: compiled root in 2.2s
2023.11.01 14:08:52 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:68: error: unclosed string literal
                    Future(Ok("He))
                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 14:09:03 INFO  compiling root (1 scala source)
2023.11.01 14:09:03 INFO  time: compiled root in 0.47s
2023.11.01 14:09:04 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:04 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:08 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:09 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:10 INFO  compiling root (1 scala source)
2023.11.01 14:09:10 INFO  time: compiled root in 0.81s
2023.11.01 14:09:11 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:14 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:15 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:15 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:18 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:68: error: unclosed character literal
                    Future(Ok('hell'))
                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 14:09:18 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:18 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:68: error: unclosed character literal
                    Future(Ok('hello'))
                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 14:09:19 INFO  compiling root (1 scala source)
2023.11.01 14:09:19 INFO  time: compiled root in 0.34s
2023.11.01 14:09:20 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:68: error: unclosed character literal
                    Future(Ok('hello'))
                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 14:09:20 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:21 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:21 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:22 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:22 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:22 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:23 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:23 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:24 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:09:24 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
2023.11.01 14:11:25 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/RegisterController.scala
scala.meta.tokenizers.TokenizeException: <input>:68: error: unclosed string literal
                    Future(Ok("Hello
                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.01 14:12:06 INFO  compiling root (1 scala source)
2023.11.01 14:12:10 INFO  time: compiled root in 4.29s
2023.11.01 14:14:01 INFO  compiling root (1 scala source)
2023.11.01 14:14:08 INFO  time: compiled root in 6.7s
2023.11.01 14:14:08 INFO  compiling root (2 scala sources)
2023.11.01 14:14:08 INFO  time: compiled root in 0.51s
2023.11.01 14:14:08 INFO  compiling root (1 scala source)
2023.11.01 14:14:11 INFO  time: compiled root in 2.79s
2023.11.01 14:14:11 INFO  compiling root (2 scala sources)
2023.11.01 14:14:11 INFO  time: compiled root in 0.83s
2023.11.01 14:14:16 INFO  compiling root (2 scala sources)
2023.11.01 14:14:20 INFO  time: compiled root in 4.42s
2023.11.01 14:14:20 INFO  compiling root (1 scala source)
2023.11.01 14:14:20 INFO  time: compiled root in 0.24s
2023.11.01 14:14:20 INFO  compiling root (2 scala sources)
2023.11.01 14:14:22 INFO  time: compiled root in 1.74s
2023.11.01 14:14:22 INFO  compiling root (1 scala source)
2023.11.01 14:14:22 INFO  time: compiled root in 0.37s
2023.11.01 14:14:24 INFO  compiling root (3 scala sources)
2023.11.01 14:14:29 INFO  time: compiled root in 4.95s
2023.11.01 14:26:06 INFO  time: code lens generation in 1.4s
2023.11.01 14:26:07 INFO  time: code lens generation in 1.37s
2023.11.01 14:26:08 INFO  running '/opt/local/sdkman/candidates/java/current/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals6353260093930023063/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2023.11.01 14:26:13 INFO  [info] welcome to sbt 1.7.2 (Amazon.com Inc. Java 1.8.0_382)
2023.11.01 14:26:16 INFO  [info] loading settings for project auth-app-backend-build-build-build from metals.sbt ...
2023.11.01 14:26:18 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/project
2023.11.01 14:26:21 INFO  [info] loading settings for project auth-app-backend-build-build from metals.sbt ...
2023.11.01 14:26:21 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project
2023.11.01 14:26:30 INFO  [success] Generated .bloop/auth-app-backend-build-build.json
2023.11.01 14:26:30 INFO  [success] Total time: 7 s, completed 11 1, 23 2:26:30 PM
2023.11.01 14:26:31 INFO  [info] loading settings for project auth-app-backend-build from metals.sbt,plugins.sbt ...
2023.11.01 14:26:31 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project
2023.11.01 14:26:36 INFO  [success] Generated .bloop/auth-app-backend-build.json
2023.11.01 14:26:38 INFO  [success] Total time: 6 s, completed 11 1, 23 2:26:38 PM
2023.11.01 14:26:53 INFO  [info] loading settings for project root from build.sbt ...
2023.11.01 14:26:53 INFO  [info]   __              __
2023.11.01 14:26:53 INFO  [info]   \ \     ____   / /____ _ __  __
2023.11.01 14:26:53 INFO  [info]    \ \   / __ \ / // __ `// / / /
2023.11.01 14:26:53 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2023.11.01 14:26:53 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2023.11.01 14:26:53 INFO  [info]       /_/               /____/
2023.11.01 14:26:53 INFO  [info] 
2023.11.01 14:26:53 INFO  [info] Version 2.8.20 running Java 1.8.0_382
2023.11.01 14:26:53 INFO  [info] 
2023.11.01 14:26:53 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2023.11.01 14:26:53 INFO  [info] https://www.playframework.com/sponsors
2023.11.01 14:26:53 INFO  [info] 
2023.11.01 14:27:05 INFO  [success] Generated .bloop/root-test.json
2023.11.01 14:27:05 INFO  [success] Generated .bloop/root.json
2023.11.01 14:27:05 INFO  [success] Total time: 8 s, completed 11 1, 23 2:27:05 PM
2023.11.01 14:27:06 INFO  time: ran 'sbt bloopInstall' in 57s
2023.11.01 14:27:06 INFO  Disconnecting from Bloop session...
2023.11.01 14:27:06 INFO  Shut down connection with build server.
2023.11.01 14:27:06 INFO  Shut down connection with build server.
2023.11.01 14:27:06 INFO  Shut down connection with build server.
2023.11.01 14:27:06 INFO  Attempting to connect to the build server...
2023.11.01 14:27:06 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 14:27:06 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 14:27:06 INFO  Attempting to connect to the build server...
2023.11.01 14:27:06 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 14:27:06 INFO  Attempting to connect to the build server...
2023.11.01 14:27:06 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 14:27:06 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 14:27:06 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 14:27:06 INFO  time: Connected to build server in 0.29s
2023.11.01 14:27:06 INFO  Connected to Build server: Bloop v1.5.11
2023.11.01 14:27:07 INFO  time: Imported build in 0.87s
2023.11.01 14:27:13 INFO  time: indexed workspace in 6.33s
2023.11.01 14:27:17 INFO  time: code lens generation in 2.54s
2023.11.01 14:27:57 INFO  compiling root (10 scala sources and 1 java source)
2023.11.01 14:28:12 INFO  time: compiled root in 14s
2023.11.01 14:28:12 INFO  compiling root-test (1 scala source)
2023.11.01 14:28:13 INFO  time: compiled root-test in 1.04s
2023.11.01 14:29:36 INFO  compiling root (1 scala source)
2023.11.01 14:29:42 INFO  time: compiled root in 5.45s
2023.11.01 14:31:32 INFO  compiling root (1 scala source)
2023.11.01 14:31:35 INFO  time: compiled root in 2.98s
Nov 01, 2023 2:34:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5324
2023.11.01 14:38:58 INFO  compiling root (1 scala source)
2023.11.01 14:38:58 INFO  time: compiled root in 0.51s
2023.11.01 14:40:51 INFO  compiling root (1 scala source)
2023.11.01 14:40:51 INFO  time: compiled root in 0.88s
2023.11.01 14:41:06 INFO  compiling root (1 scala source)
2023.11.01 14:41:08 INFO  time: compiled root in 2.1s
2023.11.01 14:42:05 INFO  compiling root (1 scala source)
2023.11.01 14:42:07 INFO  time: compiled root in 2.06s
Nov 01, 2023 2:49:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5811
2023.11.01 14:50:27 INFO  compiling root (1 scala source)
2023.11.01 14:50:30 INFO  time: compiled root in 2.91s
2023.11.01 14:51:33 INFO  compiling root (1 scala source)
2023.11.01 14:51:39 INFO  time: compiled root in 5.82s
2023.11.01 14:51:40 INFO  compiling root (1 scala source)
2023.11.01 14:51:41 INFO  time: compiled root in 1.35s
2023.11.01 14:51:50 INFO  compiling root (1 scala source)
2023.11.01 14:51:52 INFO  time: compiled root in 1.38s
2023.11.01 14:52:00 INFO  compiling root (1 scala source)
2023.11.01 14:52:01 INFO  time: compiled root in 1.47s
2023.11.01 14:52:04 INFO  compiling root (1 scala source)
2023.11.01 14:52:05 INFO  time: compiled root in 1.29s
2023.11.01 14:52:09 INFO  compiling root (1 scala source)
2023.11.01 14:52:09 INFO  time: compiled root in 0.83s
2023.11.01 15:41:05 INFO  compiling root (1 scala source)
2023.11.01 15:41:06 INFO  time: compiled root in 1.64s
Exception in thread "pool-11-thread-1" java.lang.Error: java.lang.InterruptedException
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1155)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	... 2 more
2023.11.01 15:43:50 INFO  time: code lens generation in 4.92s
2023.11.01 15:43:50 INFO  time: code lens generation in 6.67s
2023.11.01 15:43:50 INFO  time: code lens generation in 7.33s
2023.11.01 15:43:50 INFO  time: code lens generation in 9.63s
2023.11.01 15:44:04 INFO  running '/opt/local/sdkman/candidates/java/current/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals5036818620914470920/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2023.11.01 15:44:13 INFO  [info] welcome to sbt 1.7.2 (Amazon.com Inc. Java 1.8.0_382)
2023.11.01 15:44:18 INFO  [info] loading settings for project auth-app-backend-build-build-build from metals.sbt ...
2023.11.01 15:44:21 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/project
2023.11.01 15:44:26 INFO  [info] loading settings for project auth-app-backend-build-build from metals.sbt ...
2023.11.01 15:44:26 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project
2023.11.01 15:44:35 INFO  [success] Generated .bloop/auth-app-backend-build-build.json
2023.11.01 15:44:35 INFO  [success] Total time: 9 s, completed 11 1, 23 3:44:36 PM
2023.11.01 15:44:37 INFO  [info] loading settings for project auth-app-backend-build from metals.sbt,plugins.sbt ...
2023.11.01 15:44:37 INFO  [info] loading project definition from /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project
2023.11.01 15:44:43 INFO  [success] Generated .bloop/auth-app-backend-build.json
2023.11.01 15:44:45 INFO  [success] Total time: 7 s, completed 11 1, 23 3:44:45 PM
2023.11.01 15:44:57 INFO  [info] loading settings for project root from build.sbt ...
2023.11.01 15:44:57 INFO  [info]   __              __
2023.11.01 15:44:57 INFO  [info]   \ \     ____   / /____ _ __  __
2023.11.01 15:44:57 INFO  [info]    \ \   / __ \ / // __ `// / / /
2023.11.01 15:44:57 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2023.11.01 15:44:57 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2023.11.01 15:44:57 INFO  [info]       /_/               /____/
2023.11.01 15:44:57 INFO  [info] 
2023.11.01 15:44:57 INFO  [info] Version 2.8.20 running Java 1.8.0_382
2023.11.01 15:44:57 INFO  [info] 
2023.11.01 15:44:57 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2023.11.01 15:44:57 INFO  [info] https://www.playframework.com/sponsors
2023.11.01 15:44:57 INFO  [info] 
2023.11.01 15:45:07 INFO  [success] Generated .bloop/root.json
2023.11.01 15:45:07 INFO  [success] Generated .bloop/root-test.json
2023.11.01 15:45:07 INFO  [success] Total time: 5 s, completed 11 1, 23 3:45:07 PM
2023.11.01 15:45:07 INFO  time: ran 'sbt bloopInstall' in 1m3s
2023.11.01 15:45:07 INFO  Disconnecting from Bloop session...
2023.11.01 15:45:07 INFO  Shut down connection with build server.
2023.11.01 15:45:07 INFO  Shut down connection with build server.
2023.11.01 15:45:07 INFO  Shut down connection with build server.
2023.11.01 15:45:07 INFO  Attempting to connect to the build server...
2023.11.01 15:45:07 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 15:45:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 15:45:07 INFO  Attempting to connect to the build server...
2023.11.01 15:45:07 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 15:45:07 INFO  Attempting to connect to the build server...
2023.11.01 15:45:07 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.01 15:45:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 15:45:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.01 15:45:07 INFO  time: Connected to build server in 0.22s
2023.11.01 15:45:07 INFO  Connected to Build server: Bloop v1.5.11
2023.11.01 15:45:11 INFO  time: indexed workspace in 3.1s
2023.11.01 15:45:11 INFO  compiling root (1 scala source)
2023.11.01 15:45:13 INFO  time: compiled root in 2.41s
2023.11.01 15:49:37 INFO  compiling root (1 scala source)
2023.11.01 15:49:38 INFO  time: compiled root in 1.3s
2023.11.01 16:28:09 INFO  compiling root (1 scala source)
2023.11.01 16:28:10 INFO  time: compiled root in 1.48s
2023.11.01 16:28:14 INFO  compiling root (1 scala source)
2023.11.01 16:28:14 INFO  time: compiled root in 0.58s
2023.11.01 16:29:18 INFO  compiling root (4 scala sources and 1 java source)
2023.11.01 16:29:18 INFO  time: compiled root in 0.92s
2023.11.01 16:29:28 INFO  compiling root (4 scala sources and 1 java source)
2023.11.01 16:29:28 INFO  time: compiled root in 0.71s
2023.11.01 16:33:22 INFO  compiling root (4 scala sources and 1 java source)
2023.11.01 16:33:23 INFO  time: compiled root in 1.64s
2023.11.01 16:34:27 INFO  compiling root (4 scala sources and 1 java source)
2023.11.01 16:34:27 INFO  time: compiled root in 0.9s
2023.11.01 16:34:50 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:34:50 INFO  time: compiled root in 0.56s
2023.11.01 16:34:54 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:34:56 INFO  time: compiled root in 1.21s
2023.11.01 16:35:03 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:35:03 INFO  time: compiled root in 0.7s
Nov 01, 2023 4:35:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6379
Nov 01, 2023 4:35:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6381
2023.11.01 16:35:15 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:35:15 INFO  time: compiled root in 0.79s
2023.11.01 16:36:46 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:36:46 INFO  time: compiled root in 0.8s
2023.11.01 16:37:01 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:37:01 INFO  time: compiled root in 0.44s
2023.11.01 16:39:41 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:39:41 WARN  Using indexes to guess the definition of password
2023.11.01 16:39:43 WARN  Using indexes to guess the definition of Status
2023.11.01 16:39:43 INFO  time: compiled root in 2.36s
2023.11.01 16:39:49 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:39:49 INFO  time: compiled root in 0.6s
2023.11.01 16:40:28 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:40:28 INFO  time: compiled root in 0.67s
2023.11.01 16:41:06 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:41:06 INFO  time: compiled root in 0.71s
2023.11.01 16:41:18 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:41:18 INFO  time: compiled root in 0.46s
2023.11.01 16:41:25 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:41:25 INFO  time: compiled root in 0.79s
2023.11.01 16:41:33 INFO  compiling root (5 scala sources and 1 java source)
2023.11.01 16:41:41 INFO  time: compiled root in 7.95s
2023.11.01 16:49:06 INFO  compiling root (3 scala sources and 1 java source)
2023.11.01 16:49:10 INFO  time: compiled root in 4.75s
2023.11.01 16:51:53 INFO  compiling root (3 scala sources)
2023.11.01 16:51:57 INFO  time: compiled root in 3.09s
Nov 01, 2023 4:53:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/.reports/metals-full/2023-11-01/r_compiler-error_(root)_16-53-26-941.md
2023.11.01 16:55:07 INFO  compiling root (1 scala source)
2023.11.01 16:55:10 INFO  time: compiled root in 3.45s
2023.11.01 16:56:19 INFO  compiling root (1 scala source)
2023.11.01 16:56:19 INFO  time: compiled root in 0.53s
2023.11.01 16:57:06 INFO  compiling root (1 scala source)
2023.11.01 16:57:09 INFO  time: compiled root in 3.16s
2023.11.01 16:57:09 INFO  compiling root (1 scala source)
2023.11.01 16:57:09 WARN  Could not load snapshot text for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/AuthController.scala
2023.11.01 16:57:10 INFO  time: compiled root in 1.05s
2023.11.01 16:58:47 INFO  compiling root (1 scala source)
2023.11.01 16:58:54 INFO  time: compiled root in 6.84s
2023.11.01 16:58:54 INFO  compiling root (1 scala source)
2023.11.01 16:58:55 INFO  time: compiled root in 0.88s
2023.11.01 16:59:26 INFO  compiling root (1 scala source)
2023.11.01 16:59:26 INFO  time: compiled root in 0.35s
2023.11.01 17:00:08 INFO  compiling root (1 scala source)
2023.11.01 17:00:10 INFO  time: compiled root in 2.02s
2023.11.02 09:05:28 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 09:05:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 09:05:29 INFO  Connected to Build server: Bloop v1.5.11
2023.11.02 09:05:29 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 09:05:29 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 09:05:29 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 09:05:29 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 09:54:52 INFO  compiling root (1 scala source)
2023.11.02 09:55:00 INFO  time: compiled root in 7.64s
2023.11.02 10:25:33 INFO  compiling root (1 scala source)
2023.11.02 10:25:36 INFO  time: compiled root in 2.61s
Nov 02, 2023 10:25:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7643
2023.11.02 10:25:48 INFO  compiling root (1 scala source)
2023.11.02 10:25:50 INFO  time: compiled root in 2.89s
2023.11.02 10:26:13 INFO  compiling root (1 scala source)
2023.11.02 10:26:18 INFO  time: compiled root in 5.27s
2023.11.02 10:26:23 INFO  compiling root (1 scala source)
2023.11.02 10:26:28 INFO  time: compiled root in 4.35s
2023.11.02 10:28:22 INFO  compiling root (1 scala source)
2023.11.02 10:28:23 INFO  time: compiled root in 1.51s
2023.11.02 10:28:26 INFO  compiling root (1 scala source)
2023.11.02 10:28:29 INFO  time: compiled root in 3.63s
2023.11.02 10:29:09 INFO  compiling root (1 scala source)
2023.11.02 10:29:10 INFO  time: compiled root in 1.3s
2023.11.02 10:29:12 INFO  compiling root (1 scala source)
2023.11.02 10:29:15 INFO  time: compiled root in 3.73s
2023.11.02 10:29:23 INFO  compiling root (1 scala source)
2023.11.02 10:29:27 INFO  time: compiled root in 3.41s
Nov 02, 2023 10:30:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7905
2023.11.02 10:30:48 INFO  compiling root (1 scala source)
2023.11.02 10:30:49 INFO  time: compiled root in 1.33s
Exception in thread "pool-18-thread-1" java.lang.Error: java.lang.InterruptedException
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1155)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	... 2 more
2023.11.02 10:30:51 INFO  compiling root (1 scala source)
2023.11.02 10:30:54 INFO  time: compiled root in 3.49s
2023.11.02 10:31:34 INFO  compiling root (1 scala source)
2023.11.02 10:31:36 INFO  time: compiled root in 1.27s
2023.11.02 10:31:37 INFO  compiling root (1 scala source)
2023.11.02 10:31:37 INFO  time: compiled root in 0.59s
Nov 02, 2023 10:31:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8020
2023.11.02 10:31:56 INFO  compiling root (1 scala source)
2023.11.02 10:31:57 INFO  time: compiled root in 1.02s
2023.11.02 10:32:00 WARN  Using indexes to guess the definition of username
2023.11.02 10:32:04 INFO  compiling root (1 scala source)
2023.11.02 10:32:06 INFO  time: compiled root in 1.4s
2023.11.02 10:32:26 WARN  Using indexes to guess the definition of username
2023.11.02 10:32:35 INFO  compiling root (2 scala sources)
2023.11.02 10:32:35 INFO  time: compiled root in 0.5s
2023.11.02 10:32:52 INFO  compiling root (3 scala sources)
2023.11.02 10:32:56 INFO  time: compiled root in 3.92s
2023.11.02 11:29:12 INFO  compiling root (1 scala source)
2023.11.02 11:29:14 INFO  time: compiled root in 1.8s
2023.11.02 11:29:15 INFO  compiling root (1 scala source)
2023.11.02 11:29:15 INFO  time: compiled root in 0.47s
2023.11.02 11:29:28 INFO  compiling root (2 scala sources)
2023.11.02 11:29:28 INFO  time: compiled root in 0.76s
2023.11.02 11:29:28 INFO  compiling root (2 scala sources)
2023.11.02 11:29:28 INFO  time: compiled root in 0.12s
2023.11.02 11:29:31 INFO  compiling root (2 scala sources)
2023.11.02 11:29:31 INFO  time: compiled root in 0.55s
2023.11.02 11:34:18 INFO  compiling root (2 scala sources)
2023.11.02 11:34:19 INFO  time: compiled root in 1.19s
2023.11.02 11:39:59 INFO  compiling root (2 scala sources)
2023.11.02 11:40:00 INFO  time: compiled root in 1.24s
2023.11.02 13:41:23 INFO  compiling root (2 scala sources)
2023.11.02 13:41:24 INFO  time: compiled root in 1.09s
2023.11.02 13:41:39 INFO  compiling root (3 scala sources)
2023.11.02 13:41:40 INFO  time: compiled root in 1.12s
2023.11.02 13:41:47 INFO  compiling root (3 scala sources)
2023.11.02 13:41:47 INFO  time: compiled root in 0.77s
2023.11.02 13:41:51 INFO  compiling root (3 scala sources)
2023.11.02 13:41:51 INFO  time: compiled root in 0.8s
2023.11.02 13:41:56 INFO  compiling root (3 scala sources)
2023.11.02 13:41:56 INFO  time: compiled root in 0.94s
2023.11.02 13:42:01 INFO  compiling root (4 scala sources)
2023.11.02 13:42:01 INFO  time: compiled root in 0.81s
2023.11.02 13:42:07 INFO  compiling root (4 scala sources)
2023.11.02 13:42:07 INFO  time: compiled root in 0.36s
2023.11.02 13:42:15 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed comment
  /*
  ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 13:42:16 INFO  compiling root (4 scala sources)
2023.11.02 13:42:16 INFO  time: compiled root in 0.81s
2023.11.02 13:42:23 INFO  compiling root (4 scala sources)
2023.11.02 13:42:23 INFO  time: compiled root in 0.9s
2023.11.02 13:42:28 INFO  compiling root (5 scala sources)
2023.11.02 13:42:28 INFO  time: compiled root in 0.84s
2023.11.02 13:42:31 INFO  compiling root (5 scala sources)
2023.11.02 13:42:31 INFO  time: compiled root in 0.57s
2023.11.02 13:45:14 INFO  compiling root (5 scala sources)
2023.11.02 13:45:15 INFO  time: compiled root in 1.32s
2023.11.02 13:52:56 INFO  compiling root (5 scala sources)
2023.11.02 13:52:58 INFO  time: compiled root in 1.9s
2023.11.02 13:53:44 INFO  compiling root (5 scala sources)
2023.11.02 13:53:44 INFO  time: compiled root in 0.85s
2023.11.02 13:53:46 INFO  compiling root (5 scala sources)
2023.11.02 13:53:46 INFO  time: compiled root in 0.74s
2023.11.02 13:56:37 INFO  compiling root (5 scala sources)
2023.11.02 13:56:37 INFO  time: compiled root in 0.4s
2023.11.02 13:56:51 INFO  compiling root (5 scala sources)
2023.11.02 13:56:51 INFO  time: compiled root in 0.52s
2023.11.02 13:57:12 INFO  compiling root (5 scala sources)
2023.11.02 13:57:12 INFO  time: compiled root in 0.62s
2023.11.02 13:57:37 INFO  compiling root (5 scala sources)
2023.11.02 13:57:37 INFO  time: compiled root in 0.89s
2023.11.02 13:57:55 INFO  compiling root (5 scala sources)
2023.11.02 13:57:55 INFO  time: compiled root in 0.7s
2023.11.02 13:58:05 INFO  compiling root (5 scala sources)
2023.11.02 13:58:05 INFO  time: compiled root in 0.44s
2023.11.02 13:58:12 INFO  compiling root (5 scala sources)
2023.11.02 13:58:12 INFO  time: compiled root in 0.43s
2023.11.02 13:58:38 INFO  compiling root (5 scala sources)
2023.11.02 13:58:38 INFO  time: compiled root in 0.63s
2023.11.02 13:58:46 WARN  Using indexes to guess the definition of None
2023.11.02 13:58:47 INFO  compiling root (5 scala sources)
2023.11.02 13:58:47 INFO  time: compiled root in 0.46s
2023.11.02 13:59:10 INFO  compiling root (5 scala sources)
2023.11.02 13:59:10 INFO  time: compiled root in 0.51s
2023.11.02 14:00:27 INFO  compiling root (8 scala sources and 1 java source)
2023.11.02 14:00:29 INFO  time: compiled root in 2.75s
2023.11.02 14:00:30 WARN  Using indexes to guess the definition of I18nSupport
2023.11.02 14:00:31 INFO  compiling root (8 scala sources and 1 java source)
2023.11.02 14:00:50 INFO  time: compiled root in 18s
2023.11.02 14:03:43 INFO  compiling root (1 scala source)
2023.11.02 14:03:47 INFO  time: compiled root in 3.85s
Nov 02, 2023 2:14:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9405
2023.11.02 14:35:04 INFO  compiling root (1 scala source)
2023.11.02 14:35:13 INFO  time: compiled root in 9.29s
2023.11.02 14:36:11 INFO  compiling root (1 scala source)
2023.11.02 14:36:18 INFO  time: compiled root in 6.9s
2023.11.02 14:37:47 INFO  compiling root (1 scala source)
2023.11.02 14:37:47 INFO  time: compiled root in 0.94s
2023.11.02 14:38:40 INFO  compiling root (1 scala source)
2023.11.02 14:38:41 INFO  time: compiled root in 1.23s
2023.11.02 14:38:41 INFO  compiling root (1 scala source)
2023.11.02 14:38:43 INFO  time: compiled root in 1.07s
2023.11.02 14:38:47 INFO  compiling root (1 scala source)
2023.11.02 14:38:47 INFO  time: compiled root in 0.59s
2023.11.02 14:38:47 INFO  compiling root (1 scala source)
2023.11.02 14:38:48 INFO  time: compiled root in 0.36s
Nov 02, 2023 2:38:48 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 14:38:56 INFO  compiling root (2 scala sources)
2023.11.02 14:38:56 INFO  time: compiled root in 0.61s
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Option[<error>]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 209, 209, 225)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in (Long, String, Option[String], <error>) => <error>RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 194, 234, 241)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in (Long, String, Option[String], String, <error>) => <error>RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 194, 243, 250)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Option[<error>]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 233, 233, 249)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Option[<error>]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 233, 233, 242)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Array[<error>]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 240, 240, 255)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Array[<error>]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 240, 240, 249)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Array[Byte]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 240, 240, 251)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in Array[Byte]RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 240, 240, 251)
something's wrong: no file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala in (Long, String, Option[String], String, Option[Array[Byte]], <error>) => <error>RangePosition(file:///Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala, 194, 263, 270)
2023.11.02 14:39:29 INFO  compiling root (2 scala sources)
2023.11.02 14:39:29 INFO  time: compiled root in 0.64s
2023.11.02 14:39:44 INFO  compiling root (2 scala sources)
2023.11.02 14:39:44 INFO  time: compiled root in 0.93s
2023.11.02 14:39:50 INFO  compiling root (2 scala sources)
2023.11.02 14:39:50 INFO  time: compiled root in 0.85s
2023.11.02 14:39:55 INFO  compiling root (2 scala sources)
2023.11.02 14:39:57 INFO  time: compiled root in 1.18s
Nov 02, 2023 2:39:57 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 14:40:17 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/models/domain/Post.scala
scala.meta.tokenizers.TokenizeException: <input>:11: error: unclosed string interpolation
        (JsPath \ serid").write[String] and
                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

Nov 02, 2023 2:41:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10050
2023.11.02 14:41:28 INFO  compiling root (2 scala sources)
2023.11.02 14:41:28 INFO  time: compiled root in 0.45s
2023.11.02 14:41:35 INFO  compiling root (5 scala sources)
2023.11.02 14:41:39 INFO  time: compiled root in 3.69s
2023.11.02 14:41:39 INFO  compiling root (5 scala sources)
2023.11.02 14:41:40 INFO  time: compiled root in 1.48s
Nov 02, 2023 2:41:40 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 14:41:47 INFO  compiling root (5 scala sources)
2023.11.02 14:41:47 INFO  time: compiled root in 0.82s
2023.11.02 14:41:55 INFO  compiling root (5 scala sources)
2023.11.02 14:41:55 INFO  time: compiled root in 0.59s
2023.11.02 14:42:24 INFO  compiling root (5 scala sources)
2023.11.02 14:42:24 INFO  time: compiled root in 0.66s
2023.11.02 14:42:36 INFO  compiling root (5 scala sources)
2023.11.02 14:42:36 INFO  time: compiled root in 0.89s
Nov 02, 2023 2:42:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 02, 2023 2:42:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Nov 02, 2023 2:42:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
	at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:661)
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 618
	at java.lang.String.substring(String.java:1963)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2023.11.02 14:43:03 INFO  compiling root (5 scala sources)
2023.11.02 14:43:03 INFO  time: compiled root in 0.56s
2023.11.02 14:43:45 INFO  compiling root (5 scala sources)
2023.11.02 14:43:47 INFO  time: compiled root in 1.17s
Nov 02, 2023 2:45:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10659
Nov 02, 2023 2:45:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10662
Exception in thread "pool-18-thread-2" java.lang.Error: java.lang.InterruptedException
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1155)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	... 2 more
2023.11.02 14:46:26 WARN  Using indexes to guess the definition of getCombinedQueries
Nov 02, 2023 2:47:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10822
Nov 02, 2023 2:47:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10823
Nov 02, 2023 2:48:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11006
2023.11.02 14:49:31 INFO  compiling root (5 scala sources)
2023.11.02 14:49:32 INFO  time: compiled root in 1.27s
2023.11.02 14:50:14 INFO  compiling root (5 scala sources)
2023.11.02 14:50:15 INFO  time: compiled root in 1.49s
2023.11.02 14:51:06 INFO  compiling root (5 scala sources)
2023.11.02 14:51:06 INFO  time: compiled root in 0.48s
2023.11.02 14:51:32 INFO  compiling root (5 scala sources)
2023.11.02 14:51:32 INFO  time: compiled root in 0.64s
2023.11.02 14:51:42 INFO  compiling root (5 scala sources)
2023.11.02 14:51:43 INFO  time: compiled root in 1.11s
2023.11.02 14:51:45 INFO  compiling root (5 scala sources)
2023.11.02 14:51:45 INFO  time: compiled root in 0.79s
2023.11.02 14:51:49 INFO  compiling root (5 scala sources)
2023.11.02 14:51:49 INFO  time: compiled root in 0.66s
2023.11.02 14:51:56 INFO  compiling root (5 scala sources)
2023.11.02 14:51:57 INFO  time: compiled root in 1.05s
Nov 02, 2023 2:52:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11377
2023.11.02 14:52:08 INFO  compiling root (5 scala sources)
2023.11.02 14:52:09 INFO  time: compiled root in 1.03s
2023.11.02 14:52:11 INFO  compiling root (5 scala sources)
2023.11.02 14:52:11 INFO  time: compiled root in 0.45s
2023.11.02 14:52:15 INFO  compiling root (5 scala sources)
2023.11.02 14:52:17 INFO  time: compiled root in 1.63s
2023.11.02 14:52:19 INFO  compiling root (5 scala sources)
2023.11.02 14:52:19 INFO  time: compiled root in 0.46s
2023.11.02 14:52:46 INFO  compiling root (5 scala sources)
2023.11.02 14:52:46 INFO  time: compiled root in 0.72s
2023.11.02 14:53:57 INFO  compiling root (5 scala sources)
2023.11.02 14:53:57 INFO  time: compiled root in 0.91s
2023.11.02 14:54:18 INFO  compiling root (5 scala sources)
2023.11.02 14:54:19 INFO  time: compiled root in 1.53s
2023.11.02 14:54:31 INFO  compiling root (5 scala sources)
2023.11.02 14:54:32 INFO  time: compiled root in 1.13s
Nov 02, 2023 2:56:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11663
Nov 02, 2023 2:56:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11680
Nov 02, 2023 2:56:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11682
Nov 02, 2023 2:56:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11684
2023.11.02 14:56:35 INFO  compiling root (5 scala sources)
2023.11.02 14:56:35 INFO  time: compiled root in 0.5s
2023.11.02 14:56:55 INFO  compiling root (5 scala sources)
2023.11.02 14:56:55 INFO  time: compiled root in 0.77s
2023.11.02 14:56:57 INFO  compiling root (5 scala sources)
2023.11.02 14:56:57 INFO  time: compiled root in 0.86s
2023.11.02 14:57:09 INFO  compiling root (5 scala sources)
2023.11.02 14:57:09 INFO  time: compiled root in 0.72s
2023.11.02 14:58:35 WARN  Using indexes to guess the definition of Ok
Nov 02, 2023 2:58:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov 02, 2023 2:58:39 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/.reports/metals-full/2023-11-02/r_compiler-error_(root)_14-58-39-350.md
2023.11.02 14:58:39 INFO  compiling root (5 scala sources)
2023.11.02 14:58:39 INFO  time: compiled root in 0.77s
2023.11.02 14:59:13 INFO  compiling root (5 scala sources)
2023.11.02 14:59:13 INFO  time: compiled root in 0.74s
2023.11.02 15:00:41 INFO  compiling root (5 scala sources)
2023.11.02 15:00:51 INFO  time: compiled root in 9.53s
2023.11.02 15:00:51 INFO  compiling root (4 scala sources and 1 java source)
2023.11.02 15:01:13 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:01:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:01:13 INFO  Connected to Build server: Bloop v1.5.11
2023.11.02 15:01:13 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:01:14 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:01:39 INFO  compiling root (8 scala sources and 1 java source)
2023.11.02 15:01:48 INFO  time: compiled root in 9.39s
2023.11.02 15:01:48 INFO  compiling root (1 scala source)
2023.11.02 15:01:54 INFO  time: compiled root in 5.16s
2023.11.02 15:04:56 INFO  compiling root (1 scala source)
2023.11.02 15:04:59 INFO  time: compiled root in 2.97s
Nov 02, 2023 3:05:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12150
2023.11.02 15:05:12 INFO  compiling root (1 scala source)
2023.11.02 15:05:16 INFO  time: compiled root in 3.67s
2023.11.02 15:09:16 INFO  compiling root (1 scala source)
2023.11.02 15:09:21 INFO  time: compiled root in 4.65s
2023.11.02 15:09:21 INFO  compiling root (1 scala source)
2023.11.02 15:09:22 INFO  time: compiled root in 1.42s
2023.11.02 15:09:28 INFO  compiling root (1 scala source)
2023.11.02 15:09:28 INFO  time: compiled root in 0.45s
2023.11.02 15:09:49 INFO  compiling root (2 scala sources)
2023.11.02 15:09:50 INFO  time: compiled root in 1.13s
2023.11.02 15:10:07 INFO  compiling root (2 scala sources)
2023.11.02 15:10:07 INFO  time: compiled root in 0.79s
2023.11.02 15:10:10 INFO  compiling root (2 scala sources)
2023.11.02 15:10:13 INFO  time: compiled root in 3.33s
2023.11.02 15:10:13 INFO  compiling root (2 scala sources)
2023.11.02 15:10:14 INFO  time: compiled root in 1.25s
2023.11.02 15:12:44 INFO  compiling root (1 scala source)
2023.11.02 15:12:44 INFO  time: compiled root in 0.72s
2023.11.02 15:12:58 INFO  compiling root (1 scala source)
2023.11.02 15:13:02 INFO  time: compiled root in 3.58s
2023.11.02 15:13:49 INFO  compiling root (1 scala source)
2023.11.02 15:13:52 INFO  time: compiled root in 3.01s
Nov 02, 2023 3:14:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 15:14:54 INFO  compiling root (1 scala source)
2023.11.02 15:14:58 INFO  time: compiled root in 3.57s
Nov 02, 2023 3:15:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12734
Nov 02, 2023 3:15:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12735
2023.11.02 15:15:52 INFO  compiling root (1 scala source)
2023.11.02 15:15:55 INFO  time: compiled root in 3.11s
2023.11.02 15:15:55 INFO  compiling root (1 scala source)
2023.11.02 15:15:57 INFO  time: compiled root in 2.65s
2023.11.02 15:16:21 WARN  Using indexes to guess the definition of Post
2023.11.02 15:16:35 INFO  compiling root (1 scala source)
2023.11.02 15:16:38 INFO  time: compiled root in 3.25s
Nov 02, 2023 3:17:45 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -1
Nov 02, 2023 3:17:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 15:24:15 INFO  time: code lens generation in 2.31s
2023.11.02 15:24:15 INFO  time: code lens generation in 2.21s
Nov 02, 2023 3:27:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12910
Nov 02, 2023 3:27:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12913
Nov 02, 2023 3:27:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12916
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12951
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12952
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12953
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12948
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12963
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12962
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12956
Nov 02, 2023 3:27:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12957
2023.11.02 15:28:19 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:28:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:28:20 INFO  Connected to Build server: Bloop v1.5.11
2023.11.02 15:28:20 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:28:20 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:28:20 INFO  Bloop uses /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home defined at /Users/jpmruiz/.bloop/bloop.json
2023.11.02 15:28:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:28:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:28:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/project/.metals/bsp.trace.json or /Users/jpmruiz/Library/Caches/org.scalameta.metals/bsp.trace.json
2023.11.02 15:28:44 INFO  compiling root (1 scala source)
2023.11.02 15:28:50 INFO  time: compiled root in 6.32s
2023.11.02 15:28:50 INFO  compiling root (2 scala sources)
2023.11.02 15:28:55 INFO  time: compiled root in 5.27s
2023.11.02 15:43:43 INFO  compiling root (1 scala source)
2023.11.02 15:43:45 INFO  time: compiled root in 1.96s
2023.11.02 15:43:52 WARN  Using indexes to guess the definition of Post
2023.11.02 15:44:16 INFO  compiling root (1 scala source)
2023.11.02 15:44:22 INFO  time: compiled root in 6.21s
Nov 02, 2023 3:47:20 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 15:47:23 INFO  compiling root (1 scala source)
2023.11.02 15:47:33 INFO  time: compiled root in 9.26s
2023.11.02 15:49:17 INFO  compiling root (1 scala source)
2023.11.02 15:49:17 INFO  time: compiled root in 0.53s
Nov 02, 2023 3:49:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///opt/local/sdkman/candidates/java/current/src.zip%21/java/nio/file/Paths.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.NoClassDefFoundError: com/sun/source/tree/Tree
	at scala.meta.internal.pc.JavaPresentationCompiler.<init>(JavaPresentationCompiler.scala:47)
	at scala.meta.internal.metals.Compilers.loadJavaCompilerForTarget(Compilers.scala:953)
	at scala.meta.internal.metals.Compilers.$anonfun$loadJavaCompiler$1(Compilers.scala:922)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.Compilers.loadJavaCompiler(Compilers.scala:921)
	at scala.meta.internal.metals.Compilers.fromBuildTarget$1(Compilers.scala:802)
	at scala.meta.internal.metals.Compilers.loadCompiler(Compilers.scala:810)
	at scala.meta.internal.metals.Compilers.didClose(Compilers.scala:216)
	at scala.meta.internal.metals.MetalsLspService.didClose(MetalsLspService.scala:1163)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:343)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.lang.ClassNotFoundException: com.sun.source.tree.Tree
	at java.net.URLClassLoader.findClass(URLClassLoader.java:387)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	... 26 more

2023.11.02 15:49:41 ERROR Can't run javac on /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb6238473773516048021/source/Paths.java with options: [-cp
/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/sourcegraph/semanticdb-javac/0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/bloop/semanticdb/com.sourcegraph.semanticdb-javac.0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/twirl-api_2.13/1.5.1/twirl-api_2.13-1.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-server_2.13/2.8.20/play-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-test_2.13/2.8.20/play-test_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-logback_2.13/2.8.20/play-logback_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-akka-http-server_2.13/2.8.20/play-akka-http-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/filters-helpers_2.13/2.8.20/filters-helpers_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-guice_2.13/2.8.20/play-guice_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/play/scalatestplus-play_2.13/5.1.0/scalatestplus-play_2.13-5.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-slick_2.13/5.0.0/play-slick_2.13-5.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/h2database/h2/1.4.197/h2-1.4.197.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.13/1.3.1/scala-xml_2.13-1.3.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play_2.13/2.8.20/play_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/novocode/junit-interface/0.11/junit-interface-0.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/guava/30.1.1-jre/guava-30.1.1-jre.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.2.12/logback-classic-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/fluentlenium/fluentlenium-core/3.7.1/fluentlenium-core-3.7.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/htmlunit-driver/2.39.0/htmlunit-driver-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-api/3.141.59/selenium-api-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-support/3.141.59/selenium-support-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/3.141.59/selenium-firefox-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/guice/4.2.3/guice-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/extensions/guice-assistedinject/4.2.3/guice-assistedinject-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-streams_2.13/2.8.20/play-streams_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_2.13/10.1.15/akka-http-core_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws_2.13/2.8.1/play-ahc-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest_2.13/3.1.1/scalatest_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/selenium-3-141_2.13/3.1.1.0/selenium-3-141_2.13-3.1.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-java/3.141.59/selenium-java-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-cssparser/1.5.0/htmlunit-cssparser-1.5.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/codeborne/phantomjsdriver/1.4.4/phantomjsdriver-1.4.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick_2.13/3.3.2/slick_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick-hikaricp_2.13/3.3.2/slick-hikaricp_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc-api_2.13/2.8.0/play-jdbc-api_2.13-2.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/build-link/2.8.20/build-link-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.36/slf4j-api-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jul-to-slf4j/1.7.36/jul-to-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jcl-over-slf4j/1.7.36/jcl-over-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor_2.13/2.6.21/akka-actor_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor-typed_2.13/2.6.21/akka-actor-typed_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-slf4j_2.13/2.6.21/akka-slf4j_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-serialization-jackson_2.13/2.6.21/akka-serialization-jackson_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.11.4/jackson-core-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.11.4/jackson-annotations-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.11.4/jackson-datatype-jdk8-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.11.4/jackson-datatype-jsr310-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.11.4/jackson-databind-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-json_2.13/2.8.2/play-json_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/jsonwebtoken/jjwt/0.9.1/jjwt-0.9.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/xml/bind/jakarta.xml.bind-api/2.3.3/jakarta.xml.bind-api-2.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-java8-compat_2.13/1.0.2/scala-java8-compat_2.13-1.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/ssl-config-core_2.13/0.4.3/ssl-config-core_2.13-0.4.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.13/1.1.2/scala-parser-combinators_2.13-1.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/checkerframework/checker-qual/3.8.0/checker-qual-3.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/errorprone/error_prone_annotations/2.5.1/error_prone_annotations-2.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-core/1.2.12/logback-core-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/3.141.59/selenium-remote-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/atteo/classindex/classindex/3.4/classindex-3.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.10/commons-lang3-3.10.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.5.12/httpclient-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit/2.39.0/htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/bytebuddy/byte-buddy/1.8.15/byte-buddy-1.8.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-exec/1.3/commons-exec-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okhttp3/okhttp/3.11.0/okhttp-3.11.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okio/okio/1.14.0/okio-1.14.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/reactivestreams/reactive-streams/1.0.4/reactive-streams-1.0.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-stream_2.13/2.6.21/akka-stream_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_2.13/10.1.15/akka-parsing_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws_2.13/2.8.1/play-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws-standalone_2.13/2.1.2/play-ahc-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-asynchttpclient/2.1.2/shaded-asynchttpclient-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-oauth/2.1.2/shaded-oauth-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/cache/cache-api/1.1.1/cache-api-1.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalactic/scalactic_2.13/3.1.1/scalactic_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.12/scala-reflect-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/3.141.59/selenium-chrome-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-edge-driver/3.141.59/selenium-edge-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/3.141.59/selenium-ie-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-opera-driver/3.141.59/selenium-opera-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-safari-driver/3.141.59/selenium-safari-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/config/1.4.2/config-1.4.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-collection-compat_2.13/2.0.0/scala-collection-compat_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/zaxxer/HikariCP/3.2.0/HikariCP-3.2.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-exceptions/2.8.20/play-exceptions-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-parameter-names/2.11.4/jackson-module-parameter-names-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.11.4/jackson-dataformat-cbor-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-scala_2.13/2.11.4/jackson-module-scala_2.13-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/lz4/lz4-java/1.8.0/lz4-java-1.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-functional_2.13/2.8.2/play-functional_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.10.5/joda-time-2.10.5.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/activation/jakarta.activation-api/1.2.2/jakarta.activation-api-1.2.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-logging/commons-logging/1.2/commons-logging-1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-codec/commons-codec/1.11/commons-codec-1.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/xalan/2.7.2/xalan-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-text/1.8/commons-text-1.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.5.12/httpmime-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.39.0/htmlunit-core-js-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/neko-htmlunit/2.39.0/neko-htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-net/commons-net/3.6/commons-net-3.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/brotli/dec/0.1.2/dec-0.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-client/9.4.27.v20200227/websocket-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-protobuf-v3_2.13/2.6.21/akka-protobuf-v3_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone_2.13/2.1.2/play-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-xml_2.13/2.1.2/play-ws-standalone-xml_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-json_2.13/2.1.2/play-ws-standalone-json_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/cachecontrol_2.13/2.0.0/cachecontrol_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-paranamer/2.11.4/jackson-module-paranamer-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/serializer/2.7.2/serializer-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xerces/xercesImpl/2.12.0/xercesImpl-2.12.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-client/9.4.27.v20200227/jetty-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-xml/9.4.27.v20200227/jetty-xml-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-util/9.4.27.v20200227/jetty-util-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-io/9.4.27.v20200227/jetty-io-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-common/9.4.27.v20200227/websocket-common-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-http/9.4.27.v20200227/jetty-http-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-api/9.4.27.v20200227/websocket-api-9.4.27.v20200227.jar
-d
/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb6238473773516048021/target
-Xplugin:semanticdb -sourceroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb6238473773516048021/source -targetroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb6238473773516048021/target]
java.lang.NoClassDefFoundError: com/sun/source/util/JavacTask
	at scala.meta.internal.pc.JavaMetalsGlobal$.compilationTask(JavaMetalsGlobal.scala:69)
	at scala.meta.internal.metals.JavaInteractiveSemanticdb.textDocument(JavaInteractiveSemanticdb.scala:78)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$compile$2(InteractiveSemanticdbs.scala:173)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.InteractiveSemanticdbs.compile(InteractiveSemanticdbs.scala:173)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$4(InteractiveSemanticdbs.scala:98)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:98)
	at java.util.HashMap.compute(HashMap.java:1198)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2684)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:89)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:63)
	at scala.meta.internal.metals.InteractiveSemanticdbs.didFocus(InteractiveSemanticdbs.scala:145)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$6(MetalsLspService.scala:1058)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$6$adapted(MetalsLspService.scala:1056)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.ClassNotFoundException: com.sun.source.util.JavacTask
	at java.net.URLClassLoader.findClass(URLClassLoader.java:387)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at scala.meta.internal.pc.JavaMetalsGlobal$.compilationTask(JavaMetalsGlobal.scala:69)
	at scala.meta.internal.metals.JavaInteractiveSemanticdb.textDocument(JavaInteractiveSemanticdb.scala:78)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$compile$2(InteractiveSemanticdbs.scala:173)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.InteractiveSemanticdbs.compile(InteractiveSemanticdbs.scala:173)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$4(InteractiveSemanticdbs.scala:98)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:98)
	at java.util.HashMap.compute(HashMap.java:1198)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2684)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:89)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:63)
	at scala.meta.internal.metals.InteractiveSemanticdbs.didFocus(InteractiveSemanticdbs.scala:145)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$6(MetalsLspService.scala:1058)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$6$adapted(MetalsLspService.scala:1056)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 15:49:41 WARN  Running javac-semanticdb failed for jar:file:///opt/local/sdkman/candidates/java/current/src.zip!/java/nio/file/Paths.java. Output:

Nov 02, 2023 3:49:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13168
Nov 02, 2023 3:50:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13193
Nov 02, 2023 3:50:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13194
Nov 02, 2023 3:50:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13200
2023.11.02 15:50:21 INFO  compiling root (1 scala source)
2023.11.02 15:50:21 INFO  time: compiled root in 0.95s
2023.11.02 15:50:36 INFO  compiling root (1 scala source)
2023.11.02 15:50:37 INFO  time: compiled root in 1.05s
2023.11.02 15:51:42 INFO  compiling root (1 scala source)
2023.11.02 15:51:42 INFO  time: compiled root in 0.69s
2023.11.02 15:51:50 INFO  compiling root (1 scala source)
2023.11.02 15:51:52 INFO  time: compiled root in 2.32s
2023.11.02 15:56:01 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:89: error: unclosed character literal
                    'test',
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 15:56:04 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:89: error: unclosed character literal
                    'request.body.dataParts("userId").head',
                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 15:56:05 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:89: error: unclosed character literal
                    '',
                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 15:56:20 INFO  compiling root (1 scala source)
2023.11.02 15:56:23 INFO  time: compiled root in 2.42s
2023.11.02 15:56:42 WARN  Using indexes to guess the definition of create
2023.11.02 15:56:43 INFO  compiling root (1 scala source)
2023.11.02 15:56:47 INFO  time: compiled root in 3.22s
2023.11.02 15:58:43 INFO  compiling root (1 scala source)
2023.11.02 15:58:43 INFO  time: compiled root in 0.44s
2023.11.02 15:58:48 INFO  compiling root (1 scala source)
2023.11.02 15:58:51 INFO  time: compiled root in 3.33s
2023.11.02 15:58:58 INFO  compiling root (1 scala source)
2023.11.02 15:59:01 INFO  time: compiled root in 3.27s
2023.11.02 16:02:31 INFO  compiling root (1 scala source)
2023.11.02 16:02:31 INFO  time: compiled root in 0.98s
2023.11.02 16:02:42 INFO  compiling root (1 scala source)
2023.11.02 16:02:46 INFO  time: compiled root in 3.72s
2023.11.02 16:03:20 INFO  compiling root (1 scala source)
Nov 02, 2023 4:03:20 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 16:03:24 INFO  time: compiled root in 3.92s
2023.11.02 16:03:38 INFO  compiling root (1 scala source)
2023.11.02 16:03:41 INFO  time: compiled root in 3.52s
2023.11.02 16:04:06 WARN  Using indexes to guess the definition of get
2023.11.02 16:04:06 INFO  compiling root (1 scala source)
2023.11.02 16:04:12 INFO  time: compiled root in 5.92s
2023.11.02 16:07:08 INFO  compiling root (1 scala source)
2023.11.02 16:07:18 INFO  time: compiled root in 10s
Nov 02, 2023 4:08:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14006
2023.11.02 16:08:07 INFO  compiling root (1 scala source)
2023.11.02 16:08:07 INFO  time: compiled root in 0.68s
2023.11.02 16:08:15 INFO  compiling root (1 scala source)
2023.11.02 16:08:18 INFO  time: compiled root in 3.01s
Nov 02, 2023 4:08:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 16:08:36 INFO  compiling root (1 scala source)
2023.11.02 16:08:38 INFO  time: compiled root in 2.21s
2023.11.02 16:08:57 INFO  compiling root (1 scala source)
2023.11.02 16:09:01 INFO  time: compiled root in 4.14s
2023.11.02 16:09:18 WARN  Using indexes to guess the definition of get
2023.11.02 16:09:27 INFO  compiling root (1 scala source)
2023.11.02 16:09:38 INFO  time: compiled root in 11s
2023.11.02 16:10:06 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:07 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:12 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:19 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:20 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:23 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:28 WARN  Using indexes to guess the definition of create
2023.11.02 16:10:45 WARN  Using indexes to guess the definition of create
2023.11.02 16:11:04 WARN  Using indexes to guess the definition of create
2023.11.02 16:11:06 WARN  Using indexes to guess the definition of create
2023.11.02 16:11:31 INFO  compiling root (1 scala source)
2023.11.02 16:11:34 INFO  time: compiled root in 3.06s
2023.11.02 16:11:53 INFO  compiling root (1 scala source)
2023.11.02 16:11:53 INFO  time: compiled root in 0.9s
2023.11.02 16:11:58 INFO  compiling root (1 scala source)
2023.11.02 16:12:01 INFO  time: compiled root in 2.34s
Nov 02, 2023 4:12:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14500
Nov 02, 2023 4:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14519
Nov 02, 2023 4:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14520
Nov 02, 2023 4:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14523
Nov 02, 2023 4:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14526
Nov 02, 2023 4:12:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14543
2023.11.02 16:12:31 INFO  compiling root (1 scala source)
2023.11.02 16:12:34 INFO  time: compiled root in 3.28s
2023.11.02 16:12:57 INFO  compiling root (1 scala source)
2023.11.02 16:13:01 INFO  time: compiled root in 4.02s
2023.11.02 16:13:52 INFO  compiling root (1 scala source)
2023.11.02 16:13:57 INFO  time: compiled root in 5.26s
2023.11.02 16:14:13 INFO  compiling root (1 scala source)
2023.11.02 16:14:15 INFO  time: compiled root in 2.44s
2023.11.02 16:14:22 WARN  Using indexes to guess the definition of Post
2023.11.02 16:14:23 WARN  Using indexes to guess the definition of Post
Nov 02, 2023 4:15:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14705
2023.11.02 16:15:05 INFO  compiling root (1 scala source)
2023.11.02 16:15:06 INFO  time: compiled root in 1.46s
2023.11.02 16:15:35 INFO  compiling root (1 scala source)
2023.11.02 16:15:39 INFO  time: compiled root in 3.76s
2023.11.02 16:18:11 INFO  compiling root (1 scala source)
2023.11.02 16:18:14 INFO  time: compiled root in 2.63s
2023.11.02 16:20:19 INFO  compiling root (1 scala source)
2023.11.02 16:20:22 INFO  time: compiled root in 3.07s
2023.11.02 16:20:48 INFO  compiling root (1 scala source)
2023.11.02 16:20:50 INFO  time: compiled root in 1.9s
2023.11.02 16:20:59 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:89: error: unclosed character literal
                    '',
                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

Nov 02, 2023 4:21:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///opt/local/sdkman/candidates/java/current/src.zip%21/java/lang/Object.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.NoClassDefFoundError: com/sun/source/tree/Tree
	at scala.meta.internal.pc.JavaPresentationCompiler.<init>(JavaPresentationCompiler.scala:47)
	at scala.meta.internal.metals.Compilers.loadJavaCompilerForTarget(Compilers.scala:953)
	at scala.meta.internal.metals.Compilers.$anonfun$loadJavaCompiler$1(Compilers.scala:922)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.Compilers.loadJavaCompiler(Compilers.scala:921)
	at scala.meta.internal.metals.Compilers.fromBuildTarget$1(Compilers.scala:802)
	at scala.meta.internal.metals.Compilers.loadCompiler(Compilers.scala:810)
	at scala.meta.internal.metals.Compilers.didClose(Compilers.scala:216)
	at scala.meta.internal.metals.MetalsLspService.didClose(MetalsLspService.scala:1163)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:343)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.lang.ClassNotFoundException: com.sun.source.tree.Tree
	at java.net.URLClassLoader.findClass(URLClassLoader.java:387)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	... 26 more

2023.11.02 16:21:27 ERROR Can't run javac on /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb8687460898411753009/source/Object.java with options: [-cp
/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/sourcegraph/semanticdb-javac/0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/bloop/semanticdb/com.sourcegraph.semanticdb-javac.0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/twirl-api_2.13/1.5.1/twirl-api_2.13-1.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-server_2.13/2.8.20/play-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-test_2.13/2.8.20/play-test_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-logback_2.13/2.8.20/play-logback_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-akka-http-server_2.13/2.8.20/play-akka-http-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/filters-helpers_2.13/2.8.20/filters-helpers_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-guice_2.13/2.8.20/play-guice_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/play/scalatestplus-play_2.13/5.1.0/scalatestplus-play_2.13-5.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-slick_2.13/5.0.0/play-slick_2.13-5.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/h2database/h2/1.4.197/h2-1.4.197.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.13/1.3.1/scala-xml_2.13-1.3.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play_2.13/2.8.20/play_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/novocode/junit-interface/0.11/junit-interface-0.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/guava/30.1.1-jre/guava-30.1.1-jre.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.2.12/logback-classic-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/fluentlenium/fluentlenium-core/3.7.1/fluentlenium-core-3.7.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/htmlunit-driver/2.39.0/htmlunit-driver-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-api/3.141.59/selenium-api-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-support/3.141.59/selenium-support-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/3.141.59/selenium-firefox-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/guice/4.2.3/guice-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/extensions/guice-assistedinject/4.2.3/guice-assistedinject-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-streams_2.13/2.8.20/play-streams_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_2.13/10.1.15/akka-http-core_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws_2.13/2.8.1/play-ahc-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest_2.13/3.1.1/scalatest_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/selenium-3-141_2.13/3.1.1.0/selenium-3-141_2.13-3.1.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-java/3.141.59/selenium-java-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-cssparser/1.5.0/htmlunit-cssparser-1.5.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/codeborne/phantomjsdriver/1.4.4/phantomjsdriver-1.4.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick_2.13/3.3.2/slick_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick-hikaricp_2.13/3.3.2/slick-hikaricp_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc-api_2.13/2.8.0/play-jdbc-api_2.13-2.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/build-link/2.8.20/build-link-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.36/slf4j-api-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jul-to-slf4j/1.7.36/jul-to-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jcl-over-slf4j/1.7.36/jcl-over-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor_2.13/2.6.21/akka-actor_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor-typed_2.13/2.6.21/akka-actor-typed_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-slf4j_2.13/2.6.21/akka-slf4j_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-serialization-jackson_2.13/2.6.21/akka-serialization-jackson_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.11.4/jackson-core-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.11.4/jackson-annotations-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.11.4/jackson-datatype-jdk8-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.11.4/jackson-datatype-jsr310-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.11.4/jackson-databind-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-json_2.13/2.8.2/play-json_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/jsonwebtoken/jjwt/0.9.1/jjwt-0.9.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/xml/bind/jakarta.xml.bind-api/2.3.3/jakarta.xml.bind-api-2.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-java8-compat_2.13/1.0.2/scala-java8-compat_2.13-1.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/ssl-config-core_2.13/0.4.3/ssl-config-core_2.13-0.4.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.13/1.1.2/scala-parser-combinators_2.13-1.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/checkerframework/checker-qual/3.8.0/checker-qual-3.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/errorprone/error_prone_annotations/2.5.1/error_prone_annotations-2.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-core/1.2.12/logback-core-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/3.141.59/selenium-remote-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/atteo/classindex/classindex/3.4/classindex-3.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.10/commons-lang3-3.10.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.5.12/httpclient-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit/2.39.0/htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/bytebuddy/byte-buddy/1.8.15/byte-buddy-1.8.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-exec/1.3/commons-exec-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okhttp3/okhttp/3.11.0/okhttp-3.11.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okio/okio/1.14.0/okio-1.14.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/reactivestreams/reactive-streams/1.0.4/reactive-streams-1.0.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-stream_2.13/2.6.21/akka-stream_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_2.13/10.1.15/akka-parsing_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws_2.13/2.8.1/play-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws-standalone_2.13/2.1.2/play-ahc-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-asynchttpclient/2.1.2/shaded-asynchttpclient-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-oauth/2.1.2/shaded-oauth-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/cache/cache-api/1.1.1/cache-api-1.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalactic/scalactic_2.13/3.1.1/scalactic_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.12/scala-reflect-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/3.141.59/selenium-chrome-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-edge-driver/3.141.59/selenium-edge-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/3.141.59/selenium-ie-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-opera-driver/3.141.59/selenium-opera-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-safari-driver/3.141.59/selenium-safari-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/config/1.4.2/config-1.4.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-collection-compat_2.13/2.0.0/scala-collection-compat_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/zaxxer/HikariCP/3.2.0/HikariCP-3.2.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-exceptions/2.8.20/play-exceptions-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-parameter-names/2.11.4/jackson-module-parameter-names-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.11.4/jackson-dataformat-cbor-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-scala_2.13/2.11.4/jackson-module-scala_2.13-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/lz4/lz4-java/1.8.0/lz4-java-1.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-functional_2.13/2.8.2/play-functional_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.10.5/joda-time-2.10.5.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/activation/jakarta.activation-api/1.2.2/jakarta.activation-api-1.2.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-logging/commons-logging/1.2/commons-logging-1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-codec/commons-codec/1.11/commons-codec-1.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/xalan/2.7.2/xalan-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-text/1.8/commons-text-1.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.5.12/httpmime-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.39.0/htmlunit-core-js-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/neko-htmlunit/2.39.0/neko-htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-net/commons-net/3.6/commons-net-3.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/brotli/dec/0.1.2/dec-0.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-client/9.4.27.v20200227/websocket-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-protobuf-v3_2.13/2.6.21/akka-protobuf-v3_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone_2.13/2.1.2/play-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-xml_2.13/2.1.2/play-ws-standalone-xml_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-json_2.13/2.1.2/play-ws-standalone-json_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/cachecontrol_2.13/2.0.0/cachecontrol_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-paranamer/2.11.4/jackson-module-paranamer-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/serializer/2.7.2/serializer-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xerces/xercesImpl/2.12.0/xercesImpl-2.12.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-client/9.4.27.v20200227/jetty-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-xml/9.4.27.v20200227/jetty-xml-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-util/9.4.27.v20200227/jetty-util-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-io/9.4.27.v20200227/jetty-io-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-common/9.4.27.v20200227/websocket-common-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-http/9.4.27.v20200227/jetty-http-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-api/9.4.27.v20200227/websocket-api-9.4.27.v20200227.jar
-d
/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb8687460898411753009/target
-Xplugin:semanticdb -sourceroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb8687460898411753009/source -targetroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb8687460898411753009/target]
java.lang.NoClassDefFoundError: com/sun/source/util/JavacTask
	at scala.meta.internal.pc.JavaMetalsGlobal$.compilationTask(JavaMetalsGlobal.scala:69)
	at scala.meta.internal.metals.JavaInteractiveSemanticdb.textDocument(JavaInteractiveSemanticdb.scala:78)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$compile$2(InteractiveSemanticdbs.scala:173)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.InteractiveSemanticdbs.compile(InteractiveSemanticdbs.scala:173)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$4(InteractiveSemanticdbs.scala:98)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:98)
	at java.util.HashMap.compute(HashMap.java:1198)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2684)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:89)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:63)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$3(MetalsLspService.scala:1042)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 16:21:27 WARN  Running javac-semanticdb failed for jar:file:///opt/local/sdkman/candidates/java/current/src.zip!/java/lang/Object.java. Output:

2023.11.02 16:21:27 WARN  Using indexes to guess the definition of create
2023.11.02 16:21:38 INFO  compiling root (1 scala source)
2023.11.02 16:21:41 INFO  time: compiled root in 3.19s
2023.11.02 16:21:43 WARN  Using indexes to guess the definition of create
2023.11.02 16:21:43 INFO  compiling root (1 scala source)
2023.11.02 16:21:46 INFO  time: compiled root in 2.83s
2023.11.02 16:21:57 INFO  compiling root (1 scala source)
2023.11.02 16:21:59 INFO  time: compiled root in 2.02s
2023.11.02 16:22:29 INFO  compiling root (1 scala source)
2023.11.02 16:22:29 INFO  time: compiled root in 0.43s
Nov 02, 2023 4:23:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15292
2023.11.02 16:24:17 INFO  compiling root (1 scala source)
2023.11.02 16:24:21 INFO  time: compiled root in 3.77s
2023.11.02 16:24:29 INFO  compiling root (1 scala source)
2023.11.02 16:24:32 INFO  time: compiled root in 2.54s
2023.11.02 16:24:39 INFO  compiling root (1 scala source)
2023.11.02 16:24:41 INFO  time: compiled root in 2.09s
2023.11.02 16:26:45 INFO  compiling root (1 scala source)
2023.11.02 16:26:45 INFO  time: compiled root in 0.56s
Nov 02, 2023 4:27:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15622
Nov 02, 2023 4:27:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15623
Nov 02, 2023 4:27:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15624
Nov 02, 2023 4:27:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15626
2023.11.02 16:27:15 INFO  compiling root (1 scala source)
2023.11.02 16:27:15 INFO  time: compiled root in 0.88s
Nov 02, 2023 4:27:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15685
2023.11.02 16:27:48 INFO  compiling root (1 scala source)
2023.11.02 16:27:50 INFO  time: compiled root in 1.97s
2023.11.02 16:27:55 INFO  compiling root (1 scala source)
2023.11.02 16:27:57 INFO  time: compiled root in 1.9s
2023.11.02 16:29:40 INFO  compiling root (1 scala source)
2023.11.02 16:29:43 INFO  time: compiled root in 2.82s
2023.11.02 16:30:21 INFO  compiling root (1 scala source)
2023.11.02 16:30:23 INFO  time: compiled root in 2.05s
2023.11.02 16:30:39 INFO  compiling root (1 scala source)
2023.11.02 16:30:41 INFO  time: compiled root in 1.7s
2023.11.02 16:30:49 INFO  compiling root (1 scala source)
2023.11.02 16:30:51 INFO  time: compiled root in 2.29s
2023.11.02 16:32:08 INFO  compiling root (1 scala source)
2023.11.02 16:32:10 INFO  time: compiled root in 2.4s
Nov 02, 2023 4:32:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16057
2023.11.02 16:32:18 INFO  compiling root (1 scala source)
2023.11.02 16:32:23 INFO  time: compiled root in 4.59s
2023.11.02 16:33:02 INFO  compiling root (1 scala source)
2023.11.02 16:33:06 INFO  time: compiled root in 3.92s
2023.11.02 16:33:25 INFO  compiling root (1 scala source)
2023.11.02 16:33:29 INFO  time: compiled root in 3.29s
2023.11.02 16:33:32 INFO  compiling root (1 scala source)
2023.11.02 16:33:34 INFO  time: compiled root in 1.66s
2023.11.02 16:34:16 INFO  compiling root (1 scala source)
2023.11.02 16:34:18 INFO  time: compiled root in 2.06s
Nov 02, 2023 4:34:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16373
2023.11.02 16:34:58 INFO  compiling root (1 scala source)
Nov 02, 2023 4:35:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///opt/local/sdkman/candidates/java/current/src.zip%21/java/nio/file/Path.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.NoClassDefFoundError: com/sun/source/tree/Tree
	at scala.meta.internal.pc.JavaPresentationCompiler.<init>(JavaPresentationCompiler.scala:47)
	at scala.meta.internal.metals.Compilers.loadJavaCompilerForTarget(Compilers.scala:953)
	at scala.meta.internal.metals.Compilers.$anonfun$loadJavaCompiler$1(Compilers.scala:922)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.Compilers.loadJavaCompiler(Compilers.scala:921)
	at scala.meta.internal.metals.Compilers.fromBuildTarget$1(Compilers.scala:802)
	at scala.meta.internal.metals.Compilers.loadCompiler(Compilers.scala:810)
	at scala.meta.internal.metals.Compilers.didClose(Compilers.scala:216)
	at scala.meta.internal.metals.MetalsLspService.didClose(MetalsLspService.scala:1163)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:343)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.lang.ClassNotFoundException: com.sun.source.tree.Tree
	at java.net.URLClassLoader.findClass(URLClassLoader.java:387)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:418)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:352)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	... 26 more

2023.11.02 16:35:00 ERROR Can't run javac on /var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb4170188343611614881/source/Path.java with options: [-cp
/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/sourcegraph/semanticdb-javac/0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/bloop/semanticdb/com.sourcegraph.semanticdb-javac.0.9.6/semanticdb-javac-0.9.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/twirl-api_2.13/1.5.1/twirl-api_2.13-1.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-server_2.13/2.8.20/play-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-test_2.13/2.8.20/play-test_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-logback_2.13/2.8.20/play-logback_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-akka-http-server_2.13/2.8.20/play-akka-http-server_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/filters-helpers_2.13/2.8.20/filters-helpers_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-guice_2.13/2.8.20/play-guice_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/play/scalatestplus-play_2.13/5.1.0/scalatestplus-play_2.13-5.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-slick_2.13/5.0.0/play-slick_2.13-5.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/h2database/h2/1.4.197/h2-1.4.197.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.13/1.3.1/scala-xml_2.13-1.3.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play_2.13/2.8.20/play_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/novocode/junit-interface/0.11/junit-interface-0.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/guava/30.1.1-jre/guava-30.1.1-jre.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.2.12/logback-classic-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/fluentlenium/fluentlenium-core/3.7.1/fluentlenium-core-3.7.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/htmlunit-driver/2.39.0/htmlunit-driver-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-api/3.141.59/selenium-api-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-support/3.141.59/selenium-support-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/3.141.59/selenium-firefox-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/guice/4.2.3/guice-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/extensions/guice-assistedinject/4.2.3/guice-assistedinject-4.2.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-streams_2.13/2.8.20/play-streams_2.13-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_2.13/10.1.15/akka-http-core_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws_2.13/2.8.1/play-ahc-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest_2.13/3.1.1/scalatest_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalatestplus/selenium-3-141_2.13/3.1.1.0/selenium-3-141_2.13-3.1.1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-java/3.141.59/selenium-java-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-cssparser/1.5.0/htmlunit-cssparser-1.5.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/codeborne/phantomjsdriver/1.4.4/phantomjsdriver-1.4.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick_2.13/3.3.2/slick_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/slick/slick-hikaricp_2.13/3.3.2/slick-hikaricp_2.13-3.3.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-jdbc-api_2.13/2.8.0/play-jdbc-api_2.13-2.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/build-link/2.8.20/build-link-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.36/slf4j-api-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jul-to-slf4j/1.7.36/jul-to-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jcl-over-slf4j/1.7.36/jcl-over-slf4j-1.7.36.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor_2.13/2.6.21/akka-actor_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor-typed_2.13/2.6.21/akka-actor-typed_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-slf4j_2.13/2.6.21/akka-slf4j_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-serialization-jackson_2.13/2.6.21/akka-serialization-jackson_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.11.4/jackson-core-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.11.4/jackson-annotations-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.11.4/jackson-datatype-jdk8-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.11.4/jackson-datatype-jsr310-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.11.4/jackson-databind-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-json_2.13/2.8.2/play-json_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/jsonwebtoken/jjwt/0.9.1/jjwt-0.9.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/xml/bind/jakarta.xml.bind-api/2.3.3/jakarta.xml.bind-api-2.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-java8-compat_2.13/1.0.2/scala-java8-compat_2.13-1.0.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/ssl-config-core_2.13/0.4.3/ssl-config-core_2.13-0.4.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.13/1.1.2/scala-parser-combinators_2.13-1.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/checkerframework/checker-qual/3.8.0/checker-qual-3.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/errorprone/error_prone_annotations/2.5.1/error_prone_annotations-2.5.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-core/1.2.12/logback-core-1.2.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/3.141.59/selenium-remote-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/atteo/classindex/classindex/3.4/classindex-3.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.10/commons-lang3-3.10.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.5.12/httpclient-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit/2.39.0/htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/bytebuddy/byte-buddy/1.8.15/byte-buddy-1.8.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-exec/1.3/commons-exec-1.3.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okhttp3/okhttp/3.11.0/okhttp-3.11.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/squareup/okio/okio/1.14.0/okio-1.14.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/reactivestreams/reactive-streams/1.0.4/reactive-streams-1.0.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-stream_2.13/2.6.21/akka-stream_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_2.13/10.1.15/akka-parsing_2.13-10.1.15.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws_2.13/2.8.1/play-ws_2.13-2.8.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ahc-ws-standalone_2.13/2.1.2/play-ahc-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-asynchttpclient/2.1.2/shaded-asynchttpclient-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/shaded-oauth/2.1.2/shaded-oauth-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/cache/cache-api/1.1.1/cache-api-1.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalactic/scalactic_2.13/3.1.1/scalactic_2.13-3.1.1.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.12/scala-reflect-2.13.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/3.141.59/selenium-chrome-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-edge-driver/3.141.59/selenium-edge-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/3.141.59/selenium-ie-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-opera-driver/3.141.59/selenium-opera-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/seleniumhq/selenium/selenium-safari-driver/3.141.59/selenium-safari-driver-3.141.59.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/config/1.4.2/config-1.4.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-collection-compat_2.13/2.0.0/scala-collection-compat_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/zaxxer/HikariCP/3.2.0/HikariCP-3.2.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-exceptions/2.8.20/play-exceptions-2.8.20.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-parameter-names/2.11.4/jackson-module-parameter-names-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.11.4/jackson-dataformat-cbor-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-scala_2.13/2.11.4/jackson-module-scala_2.13-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/lz4/lz4-java/1.8.0/lz4-java-1.8.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-functional_2.13/2.8.2/play-functional_2.13-2.8.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.10.5/joda-time-2.10.5.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jakarta/activation/jakarta.activation-api/1.2.2/jakarta.activation-api-1.2.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-logging/commons-logging/1.2/commons-logging-1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-codec/commons-codec/1.11/commons-codec-1.11.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/xalan/2.7.2/xalan-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-text/1.8/commons-text-1.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpmime/4.5.12/httpmime-4.5.12.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.39.0/htmlunit-core-js-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sourceforge/htmlunit/neko-htmlunit/2.39.0/neko-htmlunit-2.39.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-net/commons-net/3.6/commons-net-3.6.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/brotli/dec/0.1.2/dec-0.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-client/9.4.27.v20200227/websocket-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-protobuf-v3_2.13/2.6.21/akka-protobuf-v3_2.13-2.6.21.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone_2.13/2.1.2/play-ws-standalone_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-xml_2.13/2.1.2/play-ws-standalone-xml_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-ws-standalone-json_2.13/2.1.2/play-ws-standalone-json_2.13-2.1.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/cachecontrol_2.13/2.0.0/cachecontrol_2.13-2.0.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-paranamer/2.11.4/jackson-module-paranamer-2.11.4.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xalan/serializer/2.7.2/serializer-2.7.2.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xerces/xercesImpl/2.12.0/xercesImpl-2.12.0.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-client/9.4.27.v20200227/jetty-client-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-xml/9.4.27.v20200227/jetty-xml-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-util/9.4.27.v20200227/jetty-util-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-io/9.4.27.v20200227/jetty-io-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-common/9.4.27.v20200227/websocket-common-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/jetty-http/9.4.27.v20200227/jetty-http-9.4.27.v20200227.jar:/Users/jpmruiz/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jetty/websocket/websocket-api/9.4.27.v20200227/websocket-api-9.4.27.v20200227.jar
-d
/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb4170188343611614881/target
-Xplugin:semanticdb -sourceroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb4170188343611614881/source -targetroot:/var/folders/fd/35hvtqk93rbf6rb1l8y_9c640000gp/T/metals-javac-semanticdb4170188343611614881/target]
java.lang.NoClassDefFoundError: com/sun/source/util/JavacTask
	at scala.meta.internal.pc.JavaMetalsGlobal$.compilationTask(JavaMetalsGlobal.scala:69)
	at scala.meta.internal.metals.JavaInteractiveSemanticdb.textDocument(JavaInteractiveSemanticdb.scala:78)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$compile$2(InteractiveSemanticdbs.scala:173)
	at scala.Option.fold(Option.scala:263)
	at scala.meta.internal.metals.InteractiveSemanticdbs.compile(InteractiveSemanticdbs.scala:173)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$4(InteractiveSemanticdbs.scala:98)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:98)
	at java.util.HashMap.compute(HashMap.java:1198)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2684)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:89)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:63)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$3(MetalsLspService.scala:1042)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 16:35:00 WARN  Running javac-semanticdb failed for jar:file:///opt/local/sdkman/candidates/java/current/src.zip!/java/nio/file/Path.java. Output:

2023.11.02 16:35:00 INFO  time: compiled root in 2.01s
2023.11.02 16:35:26 INFO  compiling root (1 scala source)
2023.11.02 16:35:31 INFO  time: compiled root in 5.05s
2023.11.02 16:35:52 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:77: error: Invalid literal number
                post.create(Post(l.1L,
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.getFraction(LegacyScanner.scala:814)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:416)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

Nov 02, 2023 4:35:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16497
2023.11.02 16:36:16 INFO  compiling root (1 scala source)
2023.11.02 16:36:20 INFO  time: compiled root in 3.57s
2023.11.02 16:36:28 INFO  compiling root (1 scala source)
2023.11.02 16:36:30 INFO  time: compiled root in 1.5s
2023.11.02 16:38:10 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:94: error: Invalid literal number
                  Post(l.1L,
                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.getFraction(LegacyScanner.scala:814)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:416)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

Nov 02, 2023 4:38:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16665
Nov 02, 2023 4:38:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16666
2023.11.02 16:38:24 WARN  Using indexes to guess the definition of create
2023.11.02 16:38:31 INFO  compiling root (1 scala source)
2023.11.02 16:38:31 WARN  Using indexes to guess the definition of create
2023.11.02 16:38:31 INFO  time: compiled root in 0.63s
2023.11.02 16:38:40 INFO  compiling root (1 scala source)
2023.11.02 16:38:40 INFO  time: compiled root in 0.55s
2023.11.02 16:38:40 INFO  compiling root (1 scala source)
2023.11.02 16:38:40 INFO  time: compiled root in 0.26s
2023.11.02 16:38:53 INFO  compiling root (2 scala sources)
2023.11.02 16:38:53 INFO  time: compiled root in 0.8s
2023.11.02 16:38:55 WARN  Using indexes to guess the definition of Table
Nov 02, 2023 4:39:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16863
2023.11.02 16:39:45 INFO  compiling root (2 scala sources)
2023.11.02 16:39:49 INFO  time: compiled root in 3.54s
Nov 02, 2023 4:40:18 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.02 16:40:22 INFO  compiling root (1 scala source)
2023.11.02 16:40:25 INFO  time: compiled root in 3.48s
Nov 02, 2023 4:45:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "untitled:Untitled-1"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.FileSystemNotFoundException: Provider "untitled" not installed
	at java.nio.file.Paths.get(Paths.java:147)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:131)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:608)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	... 15 more

2023.11.02 16:45:53 INFO  compiling root (1 scala source)
2023.11.02 16:45:53 INFO  time: compiled root in 0.45s
2023.11.02 16:45:59 ERROR Failed to tokenize input for semantic tokens for /Users/jpmruiz/Documents/jpmruiz-11012023/auth-app-backend/app/controllers/PostController.scala
scala.meta.tokenizers.TokenizeException: <input>:78: error: unclosed string interpolation
                  "request.body.dataParts("userId").head,
                                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:539)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)

2023.11.02 16:46:01 INFO  compiling root (1 scala source)
2023.11.02 16:46:05 INFO  time: compiled root in 3.37s
2023.11.02 16:50:49 INFO  compiling root (1 scala source)
2023.11.02 16:50:52 INFO  time: compiled root in 3.12s
2023.11.03 12:57:51 INFO  Started: Metals version 1.1.0 in folders 'D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend' for client Visual Studio Code 1.84.0.
2023.11.03 12:57:57 INFO  Attempting to connect to the build server...
2023.11.03 12:57:57 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
Nov 03, 2023 12:57:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2023.11.03 12:57:58 ERROR Starting the bsp launcher for bloop...
2023.11.03 12:57:58 ERROR Opening a bsp server connection with 'bsp --protocol tcp --port 32889'...
2023.11.03 12:57:58 ERROR Waiting for the bsp connection to come up...
2023.11.03 12:57:58 ERROR error: The command bsp --protocol tcp --port 32889 returned with an error
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2023.11.03 12:57:58 ERROR > [0m[31m[E][0m Failed to load project from d:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\.bloop\root-test.json
2023.11.03 12:57:58 ERROR error: The launcher failed to establish a bsp connection, aborting...
2023.11.03 12:57:58 ERROR Failed to connect with build server, no functionality will work.
java.lang.RuntimeException: The server did not start, got FailedToOpenBspConnection
	at bloop.launcher.LauncherMain.failPromise$1(Launcher.scala:92)
	at bloop.launcher.LauncherMain.runLauncher(Launcher.scala:119)
	at scala.meta.internal.metals.BloopServers$$anon$2.run(BloopServers.scala:500)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.lang.Thread.run(Thread.java:832)

2023.11.03 12:57:58 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\CommentController.scala
2023.11.03 12:58:09 INFO  no build target found for D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\CommentController.scala. Using presentation compiler with project's scala-library version: 3.3.1
2023.11.03 12:58:09 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\AuthController.scala
2023.11.03 12:58:09 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\CommentController.scala
2023.11.03 12:58:10 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\HomeController.scala
2023.11.03 12:58:10 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\RegisterController.scala
Nov 03, 2023 12:58:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22
2023.11.03 12:58:10 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\controllers\PostController.scala
2023.11.03 12:58:13 INFO  time: code lens generation in 14s
2023.11.03 12:58:13 INFO  time: code lens generation in 3.09s
2023.11.03 12:58:13 INFO  time: code lens generation in 3.63s
2023.11.03 12:58:13 INFO  time: code lens generation in 3.77s
2023.11.03 12:58:13 INFO  time: code lens generation in 3.77s
2023.11.03 23:18:33 INFO  Shutting down server
2023.11.03 23:18:33 INFO  shutting down Metals
2023.11.03 23:18:34 INFO  Exiting server
2023.11.04 15:45:26 INFO  Started: Metals version 1.1.0 in folders 'D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend' for client Visual Studio Code 1.84.0.
2023.11.04 15:45:28 INFO  Attempting to connect to the build server...
2023.11.04 15:45:28 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.04 15:45:34 ERROR Starting the bsp launcher for bloop...
2023.11.04 15:45:34 ERROR Opening a bsp server connection with 'bsp --protocol tcp --port 27438'...
2023.11.04 15:45:34 ERROR Waiting for the bsp connection to come up...
2023.11.04 15:45:34 ERROR Waiting for the bsp connection to come up...
2023.11.04 15:45:34 ERROR Waiting for the bsp connection to come up...
2023.11.04 15:45:34 ERROR error: The command bsp --protocol tcp --port 27438 returned with an error
2023.11.04 15:45:34 ERROR > No server running at 127.0.0.1:8212, let's fire one...
2023.11.04 15:45:34 ERROR > Resolving ch.epfl.scala:bloop-frontend_2.12:1.5.11...
2023.11.04 15:45:34 ERROR > Starting bloop server at 127.0.0.1:8212...
2023.11.04 15:45:34 ERROR > Attempting a connection to the server...
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2023.11.04 15:45:34 ERROR > [0m[31m[E][0m Failed to load project from d:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\.bloop\root.json
2023.11.04 15:45:34 ERROR error: The launcher failed to establish a bsp connection, aborting...
2023.11.04 15:45:34 ERROR Failed to connect with build server, no functionality will work.
java.lang.RuntimeException: The server did not start, got FailedToOpenBspConnection
	at bloop.launcher.LauncherMain.failPromise$1(Launcher.scala:92)
	at bloop.launcher.LauncherMain.runLauncher(Launcher.scala:119)
	at scala.meta.internal.metals.BloopServers$$anon$2.run(BloopServers.scala:500)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.lang.Thread.run(Thread.java:832)

2023.11.04 15:46:50 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\UserRepo.scala
2023.11.04 15:46:57 INFO  no build target found for D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\UserRepo.scala. Using presentation compiler with project's scala-library version: 3.3.1
2023.11.04 15:46:57 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\PostRepo.scala
2023.11.04 15:46:57 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\CommentRepo.scala
Nov 04, 2023 3:46:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5
Nov 04, 2023 3:46:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6
2023.11.04 15:46:58 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\UserRepo.scala
2023.11.04 15:46:58 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\PostRepo.scala
2023.11.04 15:47:01 INFO  time: code lens generation in 2.41s
2023.11.04 15:47:01 INFO  time: code lens generation in 3.1s
2023.11.04 15:47:01 INFO  time: code lens generation in 3.19s
Nov 04, 2023 4:23:36 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2023.11.04 17:34:03 INFO  Shutting down server
2023.11.04 17:34:03 INFO  shutting down Metals
2023.11.05 11:01:10 INFO  Started: Metals version 1.1.0 in folders 'D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend' for client Visual Studio Code 1.84.0.
2023.11.05 11:01:16 INFO  Attempting to connect to the build server...
2023.11.05 11:01:16 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 11:01:25 ERROR Starting the bsp launcher for bloop...
2023.11.05 11:01:25 ERROR Opening a bsp server connection with 'bsp --protocol tcp --port 31990'...
2023.11.05 11:01:25 ERROR Waiting for the bsp connection to come up...
2023.11.05 11:01:25 ERROR Waiting for the bsp connection to come up...
2023.11.05 11:01:25 ERROR Waiting for the bsp connection to come up...
2023.11.05 11:01:25 ERROR Waiting for the bsp connection to come up...
2023.11.05 11:01:25 ERROR Waiting for the bsp connection to come up...
2023.11.05 11:01:25 ERROR error: The command bsp --protocol tcp --port 31990 returned with an error
2023.11.05 11:01:25 ERROR > No server running at 127.0.0.1:8212, let's fire one...
2023.11.05 11:01:25 ERROR > Resolving ch.epfl.scala:bloop-frontend_2.12:1.5.11...
2023.11.05 11:01:25 ERROR > Starting bloop server at 127.0.0.1:8212...
2023.11.05 11:01:25 ERROR > Attempting a connection to the server...
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.12\scala-library-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.12\scala-compiler-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.12\scala-reflect-2.13.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\io\github\java-diff-utils\java-diff-utils\4.12\java-diff-utils-4.12.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\jline\jline\3.22.0\jline-3.22.0.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[33m[W][0m Scala instance jar d:\Users\jpmruiz\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.13.0\jna-5.13.0.jar doesn't exist!
2023.11.05 11:01:25 ERROR > [0m[31m[E][0m Failed to load project from d:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\.bloop\root.json
2023.11.05 11:01:25 ERROR error: The launcher failed to establish a bsp connection, aborting...
2023.11.05 11:01:25 ERROR Failed to connect with build server, no functionality will work.
java.lang.RuntimeException: The server did not start, got FailedToOpenBspConnection
	at bloop.launcher.LauncherMain.failPromise$1(Launcher.scala:92)
	at bloop.launcher.LauncherMain.runLauncher(Launcher.scala:119)
	at scala.meta.internal.metals.BloopServers$$anon$2.run(BloopServers.scala:500)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.lang.Thread.run(Thread.java:832)

2023.11.05 12:04:53 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\PostRepo.scala
2023.11.05 12:05:01 INFO  no build target found for D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\PostRepo.scala. Using presentation compiler with project's scala-library version: 3.3.1
2023.11.05 12:05:02 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\UserRepo.scala
2023.11.05 12:05:02 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\CommentRepo.scala
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8
2023.11.05 12:05:03 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\domain\User.scala
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18
2023.11.05 12:05:03 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\domain\Post.scala
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22
Nov 05, 2023 12:05:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23
2023.11.05 12:05:02 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\domain\Comment.scala
2023.11.05 12:05:07 INFO  time: code lens generation in 3.37s
2023.11.05 12:05:07 INFO  time: code lens generation in 3.82s
2023.11.05 12:05:07 INFO  time: code lens generation in 4.28s
2023.11.05 12:05:08 INFO  time: code lens generation in 4.84s
2023.11.05 15:36:03 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\domain\Post.scala
2023.11.05 15:36:04 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\repo\CommentRepo.scala
2023.11.05 15:36:09 WARN  no build target for: D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\app\models\domain\User.scala
2023.11.05 15:39:08 INFO  running 'C:\Program Files\Java\jdk-14\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User1\AppData\Local\Temp\metals16782613761795153824\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2023.11.05 15:39:11 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 14)
2023.11.05 15:39:12 INFO  [info] loading settings for project auth-app-backend-build-build-build from metals.sbt ...
2023.11.05 15:39:13 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project\project
2023.11.05 15:39:15 INFO  [info] loading settings for project auth-app-backend-build-build from metals.sbt ...
2023.11.05 15:39:15 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project
2023.11.05 15:39:20 INFO  [success] Generated .bloop\auth-app-backend-build-build.json
2023.11.05 15:39:20 INFO  [success] Total time: 4 s, completed Nov 5, 2023, 3:39:20 PM
2023.11.05 15:39:20 INFO  [info] loading settings for project auth-app-backend-build from metals.sbt,plugins.sbt ...
2023.11.05 15:39:20 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project
2023.11.05 15:39:24 INFO  [success] Generated .bloop\auth-app-backend-build.json
2023.11.05 15:39:24 INFO  [success] Total time: 4 s, completed Nov 5, 2023, 3:39:24 PM
2023.11.05 15:39:25 INFO  [info] loading settings for project root from build.sbt ...
2023.11.05 15:39:25 INFO  [info]   __              __
2023.11.05 15:39:25 INFO  [info]   \ \     ____   / /____ _ __  __
2023.11.05 15:39:25 INFO  [info]    \ \   / __ \ / // __ `// / / /
2023.11.05 15:39:25 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2023.11.05 15:39:25 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2023.11.05 15:39:25 INFO  [info]       /_/               /____/
2023.11.05 15:39:25 INFO  [info] 
2023.11.05 15:39:25 INFO  [info] Version 2.8.20 running Java 14
2023.11.05 15:39:25 INFO  [info] 
2023.11.05 15:39:25 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2023.11.05 15:39:25 INFO  [info] https://www.playframework.com/sponsors
2023.11.05 15:39:25 INFO  [info] 
2023.11.05 15:39:25 INFO  [info] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
2023.11.05 15:39:25 INFO  [info]   Java version is 14. Play supports only 8, 11 and, experimentally, 17.
2023.11.05 15:39:25 INFO  [info] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
2023.11.05 15:39:25 INFO  [info] 
2023.11.05 15:39:32 INFO  [success] Generated .bloop\root.json
2023.11.05 15:39:32 INFO  [success] Generated .bloop\root-test.json
2023.11.05 15:39:32 INFO  [success] Total time: 6 s, completed Nov 5, 2023, 3:39:33 PM
2023.11.05 15:39:33 INFO  time: ran 'sbt bloopInstall' in 24s
2023.11.05 15:39:33 INFO  Attempting to connect to the build server...
2023.11.05 15:39:33 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 15:39:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 15:39:33 INFO  Attempting to connect to the build server...
2023.11.05 15:39:33 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 15:39:33 INFO  Attempting to connect to the build server...
2023.11.05 15:39:33 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 15:39:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 15:39:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 15:39:33 INFO  time: Connected to build server in 0.29s
2023.11.05 15:39:33 INFO  Connected to Build server: Bloop v1.5.11
2023.11.05 15:39:33 INFO  time: Imported build in 0.18s
2023.11.05 15:39:48 INFO  time: indexed workspace in 14s
2023.11.05 15:40:07 INFO  compiling root (17 scala sources and 1 java source)
2023.11.05 15:40:28 INFO  time: compiled root in 20s
2023.11.05 15:40:28 INFO  compiling root-test (1 scala source)
2023.11.05 15:40:29 INFO  time: compiled root-test in 1.15s
2023.11.05 17:20:16 INFO  compiling root-test (1 scala source)
2023.11.05 17:20:17 INFO  time: compiled root-test in 1.23s
2023.11.05 17:20:20 INFO  running 'C:\Program Files\Java\jdk-14\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User1\AppData\Local\Temp\metals2412299885342216951\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2023.11.05 17:20:23 INFO  [info] welcome to sbt 1.7.2 (Oracle Corporation Java 14)
2023.11.05 17:20:24 INFO  [info] loading settings for project auth-app-backend-build-build-build from metals.sbt ...
2023.11.05 17:20:26 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project\project
2023.11.05 17:20:28 INFO  [info] loading settings for project auth-app-backend-build-build from metals.sbt ...
2023.11.05 17:20:28 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project
Nov 05, 2023 5:20:33 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.05 17:20:33 INFO  [success] Generated .bloop\auth-app-backend-build-build.json
2023.11.05 17:20:33 INFO  [success] Total time: 6 s, completed Nov 5, 2023, 5:20:33 PM
2023.11.05 17:20:33 INFO  [info] loading settings for project auth-app-backend-build from metals.sbt,plugins.sbt ...
2023.11.05 17:20:34 INFO  [info] loading project definition from D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project
2023.11.05 17:20:39 INFO  [success] Generated .bloop\auth-app-backend-build.json
2023.11.05 17:20:39 INFO  [success] Total time: 5 s, completed Nov 5, 2023, 5:20:40 PM
2023.11.05 17:20:41 INFO  [info] loading settings for project root from build.sbt ...
2023.11.05 17:20:41 INFO  [info]   __              __
2023.11.05 17:20:41 INFO  [info]   \ \     ____   / /____ _ __  __
2023.11.05 17:20:41 INFO  [info]    \ \   / __ \ / // __ `// / / /
2023.11.05 17:20:41 INFO  [info]    / /  / /_/ // // /_/ // /_/ /
2023.11.05 17:20:41 INFO  [info]   /_/  / .___//_/ \__,_/ \__, /
2023.11.05 17:20:41 INFO  [info]       /_/               /____/
2023.11.05 17:20:41 INFO  [info] 
2023.11.05 17:20:41 INFO  [info] Version 2.8.20 running Java 14
2023.11.05 17:20:41 INFO  [info] 
2023.11.05 17:20:41 INFO  [info] Play is run entirely by the community. Please consider contributing and/or donating:
2023.11.05 17:20:41 INFO  [info] https://www.playframework.com/sponsors
2023.11.05 17:20:41 INFO  [info] 
2023.11.05 17:20:41 INFO  [info] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
2023.11.05 17:20:41 INFO  [info]   Java version is 14. Play supports only 8, 11 and, experimentally, 17.
2023.11.05 17:20:41 INFO  [info] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
2023.11.05 17:20:41 INFO  [info] 
2023.11.05 17:20:45 INFO  [success] Generated .bloop\root.json
2023.11.05 17:20:45 INFO  [success] Generated .bloop\root-test.json
2023.11.05 17:20:45 INFO  [success] Total time: 3 s, completed Nov 5, 2023, 5:20:45 PM
2023.11.05 17:20:45 INFO  time: ran 'sbt bloopInstall' in 25s
2023.11.05 17:20:45 INFO  Disconnecting from Bloop session...
2023.11.05 17:20:45 INFO  Shut down connection with build server.
2023.11.05 17:20:45 INFO  Shut down connection with build server.
2023.11.05 17:20:45 INFO  Shut down connection with build server.
2023.11.05 17:20:45 INFO  Attempting to connect to the build server...
2023.11.05 17:20:45 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 17:20:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 17:20:46 INFO  Attempting to connect to the build server...
2023.11.05 17:20:46 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 17:20:46 INFO  Attempting to connect to the build server...
2023.11.05 17:20:46 INFO  Bloop uses C:\Program Files\Java\jdk-14 defined at C:\Users\User1\.bloop\bloop.json
2023.11.05 17:20:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 17:20:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\Practice\ScalaXVue\jpmruiz-11022023\auth-app-backend\project\project\.metals\bsp.trace.json or C:\Users\User1\AppData\Local\scalameta\metals\cache\bsp.trace.json
2023.11.05 17:20:46 INFO  time: Connected to build server in 0.18s
2023.11.05 17:20:46 INFO  Connected to Build server: Bloop v1.5.11
2023.11.05 17:20:46 INFO  time: Imported build in 0.12s
2023.11.05 17:20:57 INFO  time: indexed workspace in 11s
2023.11.05 17:21:02 INFO  compiling root-test (1 scala source)
2023.11.05 17:21:04 INFO  time: compiled root-test in 2.06s
Nov 05, 2023 5:35:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov 05, 2023 5:35:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Nov 05, 2023 7:20:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 433
2023.11.05 19:30:14 INFO  compiling root (1 scala source)
2023.11.05 19:30:17 INFO  time: compiled root in 2.88s
Nov 05, 2023 7:30:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 498
2023.11.05 19:31:27 INFO  compiling root (1 scala source)
2023.11.05 19:31:29 INFO  time: compiled root in 1.79s
Nov 05, 2023 7:31:48 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.05 19:32:00 INFO  compiling root (1 scala source)
2023.11.05 19:32:02 INFO  time: compiled root in 1.7s
2023.11.05 19:32:54 INFO  compiling root (1 scala source)
2023.11.05 19:32:55 INFO  time: compiled root in 1.57s
Nov 05, 2023 7:33:10 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2023.11.05 19:33:13 INFO  compiling root (1 scala source)
2023.11.05 19:33:15 INFO  time: compiled root in 2.18s
2023.11.05 19:34:01 WARN  Using indexes to guess the definition of create
2023.11.05 19:34:23 INFO  compiling root (1 scala source)
2023.11.05 19:34:24 INFO  time: compiled root in 1.36s
2023.11.05 19:35:08 INFO  compiling root (1 scala source)
2023.11.05 19:35:10 INFO  time: compiled root in 1.34s
2023.11.05 19:51:02 INFO  compiling root (1 scala source)
2023.11.05 19:51:04 INFO  time: compiled root in 1.65s
Nov 05, 2023 7:52:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 851
Nov 05, 2023 8:13:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 870
2023.11.05 20:13:58 INFO  compiling root-test (1 scala source)
2023.11.05 20:13:58 INFO  time: compiled root-test in 0.49s
2023.11.05 21:39:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 905
Nov 05, 2023 9:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 906
Nov 05, 2023 9:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 910
2023.11.05 21:39:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:608)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:462)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:424)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1556)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 12 more

2023.11.05 21:39:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1634)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1633)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2023.11.05 21:39:13 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:447)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1624)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1623)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2023.11.05 21:39:13 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:367)
	scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	jdk.internal.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor13.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.withPCAndAdjustLsp(Compilers.scala:1027)
	at scala.meta.internal.metals.Compilers.hover(Compilers.scala:685)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$hover$1(MetalsLspService.scala:1383)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.hover(MetalsLspService.scala:1381)
	at scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:367)
	at scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 28 more

Nov 05, 2023 9:39:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 915
Nov 05, 2023 9:39:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:608)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:462)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:424)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1556)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 12 more

2023.11.05 21:39:24 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1634)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1633)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2023.11.05 21:39:25 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:447)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1624)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1623)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

Nov 05, 2023 9:39:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:674)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\nimport sun.nio.fs.AbstractFileSystemProvider;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * \u003cpre\u003e{@code\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * \u003cpre\u003e\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * \u003cpre\u003e\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u0026gt; 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        try {\n            dir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d dir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(dir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(dir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then it creates an empty\n     * directory in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     *     is not a non-empty directory. If the target file exists and is a\n     *     symbolic link, then the symbolic link itself, not the target of\n     *     the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * \u003cpre\u003e\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * \u003c/pre\u003e\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2);) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n     *         :\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * \u003c/pre\u003e\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * \u003cpre\u003e\n     *    PosixFileAttributes attrs \u003d\n     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * \u003c/pre\u003e\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoke to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    Files.setAttribute(path, \"dos:hidden\", true);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isDirectory(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).isRegularFile(path);\n        }\n\n        try {\n            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * \u003cpre\u003e\n     *    Path path \u003d ...\n     *    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *    Files.setLastModifiedTime(path, now);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     * .\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        if (options.length \u003d\u003d 0) {\n            FileSystemProvider provider \u003d provider(path);\n            if (provider instanceof AbstractFileSystemProvider)\n                return ((AbstractFileSystemProvider)provider).exists(path);\n        }\n\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return true;\n        } catch (IOException x) {\n            // does not exist or unable to determine if file exists\n            return false;\n        }\n\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result;\n                switch (ev.type()) {\n                    case ENTRY :\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            result \u003d visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            result \u003d visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                        break;\n\n                    case START_DIRECTORY :\n                        result \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (result \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        break;\n\n                    case END_DIRECTORY :\n                        result \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            result \u003d FileVisitResult.CONTINUE;\n                        break;\n\n                    default :\n                        throw new AssertionError(\"Should not get here\");\n                }\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * \u003c/pre\u003e\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code readString(path, StandardCharsets.UTF_8) }\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * \u003cpre\u003e\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * \u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\n     * }\u003c/pre\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to:\n     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * walk(start, Integer.MAX_VALUE, options)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                Spliterator\u003cString\u003e s \u003d new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(s, false)\n                        .onClose(Files.asUncheckedRunnable(fc));\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cpre\u003e{@code\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/pre\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:320)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
  ]
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:608)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:462)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:424)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1556)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 12 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:354)
	scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2457)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1363)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1362)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:354)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 27 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1634)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1633)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2023.11.05 21:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:447)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1624)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1623)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2023.11.05 21:39:33 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:462)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:424)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1556)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 12 more

2023.11.05 21:39:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1634)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1633)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:452)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2023.11.05 21:39:35 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:628)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:248)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:462)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:564)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	java.base/java.lang.Thread.run(Thread.java:832)
```

Nov 05, 2023 9:39:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2152)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.Compilers.semanticTokens(Compilers.scala:424)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$semanticTokensFull$2(MetalsLspService.scala:1556)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 12 more

Nov 05, 2023 9:39:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-14/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:645)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:642)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-14/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2938)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3109)
	at java.base/java.net.URI$Parser.parse(URI.java:3145)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2023.11.05 23:26:40 INFO  Shutting down server
2023.11.05 23:26:43 INFO  shutting down Metals
